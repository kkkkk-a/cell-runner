<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ã‚»ãƒ«ãƒ©ãƒ³ãƒŠãƒ¼</title>
    <link rel="icon" type="image/png" href="favicon.ico">
    <style>
        html,
        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            background-color: #34495e;
            font-family: sans-serif;
            overflow: hidden;
            user-select: none;
        }

        /* --- å…¨ä½“ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ --- */
        .game-container {
            display: flex;
            flex-direction: row;
            width: 100%;
            height: 100%;
        }

        /* --- å·¦ãƒ‘ãƒãƒ« (ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼æ“ä½œ & ãƒ‰ãƒƒãƒˆçµµå·¥æˆ¿) --- */
        #pixel-art-editor {
            flex: 0 0 clamp(320px, 25vw, 380px);
            padding: 15px;
            background-color: #2c3e50;
            color: #ecf0f1;
            border-right: 2px solid #000;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        /* --- å·¦ãƒ‘ãƒãƒ«ä¸Šéƒ¨ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼æƒ…å ± --- */
        .legend-header {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
        }

        #image-upload-container,
        #stats-display {
            flex: 1;
        }

        #stats-display {
            margin-top: 0;
        }

        /* --- ä¸­å¤®ãƒ‘ãƒãƒ« (ã‚²ãƒ¼ãƒ ç”»é¢ & ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆèª¬æ˜) --- */
        .main-content {
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-width: 0;
            padding: 20px;
            gap: 10px;
            box-sizing: border-box;
        }

        /* --- ã‚²ãƒ¼ãƒ ç”»é¢ãƒ©ãƒƒãƒ‘ãƒ¼ --- */
        .game-wrapper {
            position: relative;
            flex-shrink: 0;
        }

        canvas {
            background-color: #87ceeb;
            border: 2px solid #000;
            width: 100%;
            height: 100%;
            display: block;
        }

        /* --- æ¨ªé•·ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆèª¬æ˜ (å‡¡ä¾‹) --- */
        #legend {
            width: 95%;
            max-width: 804px;
            height: 100px;
            padding: 15px;
            background-color: #2c3e50;
            color: #ecf0f1;
            border-radius: 8px;
            border: 2px solid #000;
            flex-shrink: 0;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 10px 15px;
            box-sizing: border-box;
            overflow: auto;
        }

        .legend-item {
            display: flex;
            align-items: center;
        }

        .legend-item span {
            font-size: clamp(12px, 0.8vw, 15px);
        }

        .legend-shape {
            width: 30px;
            height: 30px;
            margin-right: 15px;
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
        }

        /* --- å‡¡ä¾‹å†…ã®å€‹åˆ¥ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ --- */
        #image-upload-container {
            padding: 10px;
            background-color: #3d566e;
            border-radius: 5px;
            text-align: center;
        }

        #image-upload-container label {
            font-weight: bold;
            font-size: 14px;
        }

        #player-image-upload {
            margin-top: 5px;
            width: 100%;
        }

        #stats-display {
            padding-top: 10px;
            text-align: center;
            font-weight: bold;
            font-size: 14px;
        }

        /* --- å…±é€šãƒœã‚¿ãƒ³ --- */
        .custom-btn {
            width: 100%;
            padding: 5px;
            margin-top: 5px;
            background-color: #7f8c8d;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }

        .custom-btn:hover {
            background-color: #95a5a6;
        }

        /* --- å‡¡ä¾‹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå½¢çŠ¶ã‚¹ã‚¿ã‚¤ãƒ« --- */
        .shape-player {
            background-color: #000000;
        }

        .shape-platform {
            background-color: #27ae60;
            height: 15px;
        }

        .shape-ice {
            background-color: #a2e0ff;
            border: 1px solid #74b9ff;
            height: 13px;
        }

        .shape-fragile {
            background-color: #e67e22;
            height: 15px;
        }

        .shape-moving {
            background-color: #576574;
            height: 15px;
        }

        .shape-jump-pad {
            background-color: #9b59b6;
            height: 10px;
        }

        .shape-spike {
            width: 0;
            height: 0;
            background-color: transparent;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-bottom: 25px solid #836d48;
        }

        .shape-ground-enemy {
            background-color: #34495e;
            border: 1px solid #ecf0f1;
        }

        .shape-air-enemy {
            background-color: #9b59b6;
            border-radius: 50%;
        }

        .shape-turret {
            background-color: #836d48;
            border-top-left-radius: 15px;
            border-top-right-radius: 15px;
        }

        .shape-coin {
            background-color: #f1c40f;
            border-radius: 50%;
            border: 2px solid #f39c12;
        }

        .shape-ladder {
            background-image: linear-gradient(#cd853f 2px, transparent 2px), linear-gradient(#cd853f 2px, transparent 2px), linear-gradient(to right, #cd853f 2px, transparent 2px), linear-gradient(to right, #cd853f 2px, transparent 2px);
            background-size: 100% 10px, 100% 10px, 10px 100%, 10px 100%;
            background-repeat: repeat-y, repeat-y, repeat-x, repeat-x;
            background-position: 0 0, 0 100%, 0 0, 100% 0;
            height: 28px;
            width: 28px;
            border: none;
        }

        .shape-merchant {
            background-color: #DAA520;
            /* å•†äººã®è‰² */
        }

        .shape-item {
            background-color: #4a637b;
            border-radius: 5px;
        }

        /* --- ã‚²ãƒ¼ãƒ ç”»é¢ä¸Šã®UI --- */
        #game-ui {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        #inventory {
            display: flex;
            gap: 15px;
            background-color: #2c3e50;
            /* â˜…â˜…â˜… èƒŒæ™¯è‰²ã‚’å‡¡ä¾‹ã¨çµ±ä¸€ â˜…â˜…â˜… */
            border-radius: 8px;
            /* â˜…â˜…â˜… è§’ä¸¸ã‚’èª¿æ•´ â˜…â˜…â˜… */
            border: 2px solid #000;
            /* â˜…â˜…â˜… æ ç·šã‚’è¿½åŠ ã—ã¦çµ±ä¸€æ„Ÿã‚’å‡ºã™ â˜…â˜…â˜… */
            width: auto;
            /* â˜…â˜…â˜… å¹…ã‚’è‡ªå‹•ã«è¨­å®š â˜…â˜…â˜… */
            max-width: 95%;
            /* â˜…â˜…â˜… ã¯ã¿å‡ºã•ãªã„ã‚ˆã†ã«æœ€å¤§å¹…ã‚’æŒ‡å®š â˜…â˜…â˜… */
        }

        .item-display {
            display: flex;
            align-items: center;
            color: white;
            font-size: 20px;
            font-weight: bold;
        }

        .item-icon {
            width: 24px;
            height: 24px;
            margin-right: 8px;
        }

        /* --- ã‚¹ãƒãƒ›ç”¨æ“ä½œãƒœã‚¿ãƒ³ --- */
        #mobile-controls {
            display: none;
            width: 100%;
            padding: 0 10px;
            box-sizing: border-box;
            justify-content: space-between;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            position: relative;
            /* â˜…â˜…â˜… å­è¦ç´ ã‚’é…ç½®ã™ã‚‹åŸºæº–ã«ã™ã‚‹ãŸã‚è¿½åŠ  â˜…â˜…â˜… */
            min-height: 80px;
            /* â˜…â˜…â˜… ãƒœã‚¿ãƒ³ã®é«˜ã•ã‚’ç¢ºä¿ã™ã‚‹ãŸã‚è¿½åŠ  â˜…â˜…â˜… */
        }

        .control-group {
            display: flex;
            gap: 20px;
        }

        .control-btn {
            /* â˜…â˜…â˜… ã‚µã‚¤ã‚ºã‚’å¯å¤‰ã«å¤‰æ›´ â˜…â˜…â˜… */
            width: clamp(25px, 10vw, 50px);
            height: clamp(25px, 10vw, 50px);
            font-size: clamp(18px, 4vw, 24px);

            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            border: 2px solid rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
        }

        #btn-action {
            font-size: 24px;
        }

        /* --- ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ç”»é¢ --- */
        #game-over-screen {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            color: white;
            text-align: center;
            background-color: rgba(0, 0, 0, 0.7);
        }

        .tweet-button {
            display: inline-block;
            margin-top: 20px;
            padding: 10px 20px;
            background-color: #1DA1F2;
            color: white;
            text-decoration: none;
            border-radius: 20px;
            font-weight: bold;
            font-size: 16px;
        }

        /* --- ãƒ‰ãƒƒãƒˆçµµã‚¨ãƒ‡ã‚£ã‚¿ --- */
        #pixel-grid {
            display: grid;
            grid-template-columns: repeat(32, 1fr);
            width: 100%;
            height: auto;
            aspect-ratio: 1 / 1;
            border: 1px solid #7f8c8d;
            background-color: #ecf0f1;
            cursor: crosshair;
            box-sizing: border-box;
            /* â† â˜…â˜…â˜… ã“ã‚ŒãŒè§£æ±ºç­–ã§ã™ â˜…â˜…â˜… */
        }

        .pixel-cell {
            width: 100%;
            height: 100%;
            background-color: transparent;
            box-sizing: border-box;
        }

        #color-palette {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 5px;
            margin-top: 10px;
        }

        .color-swatch {
            width: 100%;
            height: 25px;
            border: 2px solid transparent;
            cursor: pointer;
            box-sizing: border-box;
        }

        .color-swatch.active {
            border-color: #f1c40f;
            transform: scale(1.1);
        }

        /* --- å–å¼•ãƒ¡ãƒ‹ãƒ¥ãƒ¼ --- */
        #trade-menu {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background-color: #2c3e50;
            color: white;
            padding: 20px;
            border: 2px solid #ecf0f1;
            border-radius: 10px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #trade-menu button {
            padding: 10px;
            font-size: 16px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #trade-menu button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }

        /* --- ãƒ“ãƒ¼ãƒˆã‚·ãƒ¼ã‚±ãƒ³ã‚µãƒ¼ --- */
        #sequencer {
            margin-top: 15px;
        }

        .part-row {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .part-label {
            font-weight: bold;
            width: 55px;
            padding-right: 10px;
            font-size: 0.5em;
            flex-shrink: 0;
        }

        .step-buttons {
            display: grid;
            grid-template-columns: repeat(16, 1fr);
            gap: 2px;
            width: 100%;
        }

        .step-btn {
            width: 100%;
            aspect-ratio: 1 / 1;
            background-color: #576574;
            border: 1px solid #2c3e50;
            border-radius: 3px;
            cursor: pointer;
        }

        .step-btn.active {
            background-color: #f1c40f;
        }

        .step-btn.playing {
            box-shadow: inset 0 0 4px #fff;
        }

        .step-btn.beat {
            border-color: #95a5a6;
        }

        #sequencer-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        #sequencer-controls .custom-btn {
            flex-grow: 1;
        }

        #track-info {
            font-size: 13px;
            font-weight: bold;
            background-color: #3d566e;
            padding: 5px;
            border-radius: 4px;
            text-align: center;
        }

        @media (max-width: 750px) {

            /* --- ãƒšãƒ¼ã‚¸å…¨ä½“ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’è¨±å¯ --- */
            html,
            body {
                overflow: auto;
                /* ç¸¦ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’è¨±å¯ */
                height: auto;
                /* é«˜ã•ã‚’ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã«åˆã‚ã›ã‚‹ */
            }

            /* --- å…¨ä½“ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã‚’ç¸¦ä¸¦ã³ã«å¤‰æ›´ --- */
            .game-container {
                flex-direction: column;
                /* â˜…ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®å¿ƒè‡“éƒ¨ï¼ç¸¦ä¸¦ã³ã«å¤‰æ›´ */
                height: auto;
            }

            /* --- å·¦ãƒ‘ãƒãƒ«ã‚’ç”»é¢ä¸Šéƒ¨ã«é…ç½® --- */
            #pixel-art-editor {
                flex: 1 0 auto;
                /* é«˜ã•ãŒè‡ªå‹•ã§æ±ºã¾ã‚‹ã‚ˆã†ã« */
                width: 100%;
                /* æ¨ªå¹…ã‚’ç”»é¢ã„ã£ã±ã„ã« */
                box-sizing: border-box;
                /* paddingã‚’å«ã‚ã¦å¹…100%ã«ã™ã‚‹ */
                border-right: none;
                /* å³ã®å¢ƒç•Œç·šã‚’æ¶ˆã™ */
                border-bottom: 2px solid #000;
                /* ä»£ã‚ã‚Šã«ä¸‹ã®å¢ƒç•Œç·šã‚’è¿½åŠ  */
                overflow-y: visible;
                /* ãƒ‘ãƒãƒ«è‡ªä½“ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã¯ä¸è¦ã« */
            }

            /* --- ä¸­å¤®ãƒ‘ãƒãƒ«ã‚’ç”»é¢ä¸­å¤®ã«é…ç½® --- */
            .main-content {
                padding: 10px;
                /* ä½™ç™½ã‚’å°‘ã—è©°ã‚ã‚‹ */
                gap: 10px;
            }

            .game-wrapper {
                width: 100%;
                /* â˜…ã‚²ãƒ¼ãƒ ãƒ©ãƒƒãƒ‘ãƒ¼ã®å¹…ã‚’è¦ªè¦ç´ (main-content)ã«åˆã‚ã›ã‚‹ */
                height: auto;
                /* é«˜ã•ã¯å¹…ã«å¿œã˜ã¦è‡ªå‹•ã§æ±ºã‚ã‚‹ */
                aspect-ratio: 800 / 600;
                /* â˜…å¸¸ã«ã‚²ãƒ¼ãƒ ã®æ¯”ç‡ã‚’ä¿ã¤ */
            }

            #mobile-controls {
                display: flex;
                /* â˜…â˜…â˜… ã‚¹ãƒãƒ›ã®æ™‚ã ã‘flexã§è¡¨ç¤ºã™ã‚‹ â˜…â˜…â˜… */
            }

            /* --- ãƒªã‚µã‚¤ã‚ºç”¨ã®JavaScriptã‚’ä¸Šæ›¸ãã™ã‚‹ãŸã‚ --- */
            /* JSãŒwidth/heightã‚’styleå±æ€§ã§è¨­å®šã—ã¾ã™ãŒã€ */
            /* ãã‚Œã‚’ç„¡åŠ¹åŒ–ã—ã¦CSSã§åˆ¶å¾¡ã—ã¾ã™ */
            .game-wrapper {
                width: 100% !important;
                height: auto !important;
            }
        }

        /* --- ãƒ˜ãƒ«ãƒ—ãƒ¢ãƒ¼ãƒ€ãƒ« --- */
        .help-btn {
            width: auto;
            /* å¹…ã‚’è‡ªå‹•èª¿æ•´ */
            max-width: 250px;
            /* æœ€å¤§å¹…ã‚’æŒ‡å®š */
            padding: 10px 20px;
            font-size: 16px;
            font-weight: bold;
            background-color: #3498db;
            /* ãƒœã‚¿ãƒ³ã®è‰²ã‚’é’ç³»ã«å¤‰æ›´ */
            color: white;
            border: 2px solid #ecf0f1;
            border-radius: 8px;
        }

        .help-btn:hover {
            background-color: #5dade2;
        }

        #help-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: none;
            /* åˆæœŸçŠ¶æ…‹ã¯éè¡¨ç¤º */
            justify-content: center;
            align-items: center;
            z-index: 200;
            padding: 20px;
            box-sizing: border-box;
        }

        #help-modal.open {
            /* â† â˜…â˜…â˜… .modal-overlay ã‹ã‚‰ #help-modal ã«å¤‰æ›´ â˜…â˜…â˜… */
            display: flex;
            /* è¡¨ç¤ºçŠ¶æ…‹ */
        }

        .modal-content {
            background-color: #34495e;
            color: #ecf0f1;
            padding: 25px 30px;
            border-radius: 10px;
            border: 2px solid #ecf0f1;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
            position: relative;
            /* é–‰ã˜ã‚‹ãƒœã‚¿ãƒ³ã®åŸºæº– */
            font-size: clamp(14px, 1.2vw, 16px);
            line-height: 1.6;
        }

        .modal-content h2,
        .modal-content h3 {
            color: #f1c40f;
            margin-top: 0;
            border-bottom: 1px solid #7f8c8d;
            padding-bottom: 5px;
        }

        .modal-content h3 {
            margin-top: 20px;
        }

        .modal-content ul {
            padding-left: 20px;
        }

        .modal-content li {
            margin-bottom: 10px;
        }

        .close-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: white;
            font-size: 30px;
            cursor: pointer;
            padding: 0;
            line-height: 1;
        }

        /* --- ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ« --- */
        #animation-controls {
            margin: 10px 0;
            padding: 8px;
            background-color: #3d566e;
            border-radius: 5px;
            color: white;
            font-size: 13px;
        }

        /* --- ãƒ”ã‚¯ã‚»ãƒ«ã‚°ãƒªãƒƒãƒ‰ã®åˆ†å‰²ç·š --- */
        .pixel-cell.split-h {
            /* å‚ç›´ç·š */
            border-right: 1px solid rgba(255, 0, 0, 0.6);
        }

        .pixel-cell.split-v {
            /* æ°´å¹³ç·š */
            border-bottom: 1px solid rgba(255, 0, 0, 0.6);
        }

        /* --- ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é€Ÿåº¦ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ --- */
        #anim-speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: center;
        }

        #anim-speed-control input[type="range"] {
            flex-grow: 1;
        }

        #anim-speed-control span {
            font-weight: bold;
            width: 20px;
            text-align: right;
        }



        /* --- ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚¹ãƒ­ãƒƒãƒˆ --- */
        #char-slots {
            position: absolute;
            bottom: 4px;
            /* ã‚²ãƒ¼ãƒ ç”»é¢ã®ä¸‹ã‹ã‚‰10pxã®ä½ç½®ã« */
            left: 4px;
            pointer-events: auto;
            /* â˜…â˜…â˜… ã‚¯ãƒªãƒƒã‚¯ã§ãã‚‹ã‚ˆã†ã«å¿…ãšæŒ‡å®š â˜…â˜…â˜… */
            z-index: 10;
            /* ä»–ã®UIã‚ˆã‚Šæ‰‹å‰ã« */
        }

        .char-slot {
            width: clamp(30px, 8vw, 50px);
            height: clamp(30px, 8vw, 50px);
            font-size: clamp(18px, 7vw, 36px);
            background-color: rgba(255, 255, 255, 0.4);
            border: 2px solid rgba(255, 255, 255, 0.6);
            border-radius: 8px;
            color: white;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            cursor: pointer;
            /* ã‚­ãƒ£ãƒ©ã‚µãƒ ãƒã‚¤ãƒ«ç”¨ã®è¨­å®š */
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
        }
    </style>
</head>

<body>
    <div class="game-container">

        <!-- === å·¦ãƒ‘ãƒãƒ« (ãƒ‰ãƒƒãƒˆçµµå·¥æˆ¿ & ã‚·ãƒ¼ã‚±ãƒ³ã‚µãƒ¼) === -->
        <div id="pixel-art-editor">
            <div class="legend-header">
                <div id="image-upload-container">
                    <label for="player-image-upload">ã‚­ãƒ£ãƒ©ç”»åƒã‚’å¤‰æ›´</label>
                    <input type="file" id="player-image-upload" accept="image/*">
                    <button id="reset-image-btn" class="custom-btn">ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«æˆ»ã™</button>
                </div>
                <div id="stats-display">
                    <div id="color-tendency-preview">-</div>
                    <div id="speed-bonus-display">ã‚¹ãƒ”ãƒ¼ãƒ‰è£œæ­£: +0.00</div>
                    <div id="jump-bonus-display">ã‚¸ãƒ£ãƒ³ãƒ—è£œæ­£: +0.00</div>
                    <div id="bullet-size-display">å¼¾ã‚µã‚¤ã‚º: 8.00</div>
                    <div id="bullet-speed-display">å¼¾é€Ÿ: 8.00</div>
                </div>
            </div>
            <div id="pixel-grid"></div>
            <div id="color-palette"></div>
            <button id="apply-pixel-art" class="custom-btn">ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã«é©ç”¨</button>
            <div style="display: flex; gap: 5px;">
                <button id="save-to-slot-1" class="custom-btn">ã‚¹ãƒ­ãƒƒãƒˆ1ä¿å­˜</button>
                <button id="save-to-slot-2" class="custom-btn">ã‚¹ãƒ­ãƒƒãƒˆ2ä¿å­˜</button>
                <button id="save-to-slot-3" class="custom-btn">ã‚¹ãƒ­ãƒƒãƒˆ3ä¿å­˜</button>
            </div>
            <button id="clear-pixel-grid" class="custom-btn">å…¨æ¶ˆå»</button>
            <button id="save-pixel-art" class="custom-btn">ãƒ‰ãƒƒãƒˆçµµã‚’ä¿å­˜(PNG)</button>
            <button id="save-pixel-art-json" class="custom-btn">ãƒ‰ãƒƒãƒˆçµµã‚’ä¿å­˜(JSON)</button>
            <button id="load-pixel-art-json" class="custom-btn">ãƒ‰ãƒƒãƒˆçµµã‚’èª­è¾¼(JSON)</button>
            <input type="file" id="pixel-art-file-input" accept=".json" style="display: none;">

            <div id="animation-controls">
                <label><input type="radio" name="anim-mode" value="none" checked> ã‚¢ãƒ‹ãƒ¡ãªã—</label>
                <label><input type="radio" name="anim-mode" value="2frames"> 2åˆ†å‰² (1x2)</label>
                <label><input type="radio" name="anim-mode" value="4frames"> 4åˆ†å‰² (2x2)</label>
                <label><input type="radio" name="anim-mode" value="6frames"> 6åˆ†å‰² (3x2)</label>
                <div id="anim-speed-control">
                    <label for="anim-speed-slider">é€Ÿåº¦(ãƒ•ãƒ¬ãƒ¼ãƒ é–“éš”):</label>
                    <input type="range" id="anim-speed-slider" min="2" max="30" value="10">
                    <span id="anim-speed-display">10</span>
                </div>
            </div>

            <div id="sequencer">
                <div id="sequencer-grid"></div>
                <div id="sequencer-controls">
                    <button id="play-pause-btn" class="custom-btn">å†ç”Ÿ</button>
                    <button id="clear-sequencer-btn" class="custom-btn">å…¨æ¶ˆå»</button>
                    <button id="save-beat-btn" class="custom-btn">ä¿å­˜</button>
                    <button id="load-beat-btn" class="custom-btn">èª­è¾¼</button>
                    <input type="file" id="beat-file-input" accept=".json" style="display: none;">
                </div>
                <div id="bpm-control"
                    style="margin-top: 10px; display: flex; align-items: center; gap: 10px; color: white;">
                    <label for="bpm-slider" style="font-weight: bold; font-size: 14px;">BPM:</label>
                    <input type="range" id="bpm-slider" min="60" max="180" value="120" style="flex-grow: 1;">
                    <span id="bpm-display"
                        style="font-weight: bold; font-size: 14px; width: 30px; text-align: right;">120</span>
                </div>
                <div id="track-info">
                    <span>ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«: OFF</span> | <span>ã‚¹ã‚³ã‚¢å€ç‡: x1.0</span>
                </div>
            </div>
        </div>

        <!-- === ä¸­å¤®ãƒ‘ãƒãƒ« (ã‚²ãƒ¼ãƒ ç”»é¢ & ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆèª¬æ˜) === -->
        <div class="main-content">
            <div id="inventory">
                <div class="item-display"><span class="item-icon">ğŸ›¡ï¸</span><span id="shield-rescues-count">0</span>
                </div>
                <div class="item-display"><span class="item-icon">ğŸ•Šï¸</span><span id="fall-rescues-count">0</span>
                </div>
                <div class="item-display"><span class="item-icon">ğŸª¶</span><span id="double-jumps-count">0</span>
                </div>
                <div class="item-display"><span class="item-icon">â³</span><span id="time-stops-count">0</span></div>
                <div class="item-display"><span class="item-icon">ğŸ”¥</span><span id="power-ups-count">0</span></div>
            </div>
            <div class="game-wrapper">
                <canvas id="gameCanvas"></canvas>



                <div id="game-over-screen">
                    <div id="game-over-text"></div>
                    <a id="tweet-link" href="#" target="_blank" class="tweet-button">ã‚¹ã‚³ã‚¢ã‚’ãƒ„ã‚¤ãƒ¼ãƒˆ â“</a>
                </div>

                <div id="char-slots" class="control-group">
                    <div class="char-slot" id="slot-1">1</div>
                    <div class="char-slot" id="slot-2">2</div>
                    <div class="char-slot" id="slot-3">3</div>
                </div>
            </div>


            <div id="mobile-controls">
                <div class="control-group">
                    <div class="control-btn" id="btn-left">â—€</div>
                    <div class="control-btn" id="btn-right">â–¶</div>
                </div>

                <div class="control-group">
                    <div class="control-btn" id="btn-action">â—</div>
                    <div class="control-btn" id="btn-jump">â–²</div>
                </div>
            </div>
            <div id="legend">
                <button id="show-help-btn" class="custom-btn help-btn">éŠã³æ–¹ãƒ˜ãƒ«ãƒ—</button>
                <h4>ãƒ–ãƒ­ãƒƒã‚¯èª¬æ˜</h4>
                <div class="legend-item">
                    <div class="legend-shape shape-player"></div><span>ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼</span>
                </div>
                <div class="legend-item">
                    <div class="legend-shape shape-merchant"></div><span>å•†äºº</span>
                </div>
                <div class="legend-item">
                    <div class="legend-shape shape-platform"></div><span>é€šå¸¸ã®è¶³å ´</span>
                </div>
                <div class="legend-item">
                    <div class="legend-shape shape-ice"></div><span>æ°·ã®åºŠ (æ»‘ã‚‹)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-shape shape-fragile"></div><span>å´©ã‚Œã‚‹åºŠ</span>
                </div>
                <div class="legend-item">
                    <div class="legend-shape shape-moving"></div><span>å‹•ãåºŠ</span>
                </div>
                <div class="legend-item">
                    <div class="legend-shape shape-jump-pad"></div><span>ã‚¸ãƒ£ãƒ³ãƒ—å°</span>
                </div>
                <div class="legend-item">
                    <div class="legend-shape shape-spike"></div><span>æ£˜</span>
                </div>
                <div class="legend-item">
                    <div class="legend-shape shape-ground-enemy"></div><span>åœ°ä¸Šæ•µ</span>
                </div>
                <div class="legend-item">
                    <div class="legend-shape shape-air-enemy"></div><span>ç©ºä¸­æ•µ</span>
                </div>
                <div class="legend-item">
                    <div class="legend-shape shape-turret"></div><span>ç ²å°</span>
                </div>
                <div class="legend-item">
                    <div class="legend-shape shape-coin"></div><span>ã‚¿ã‚¤ãƒ ã‚³ã‚¤ãƒ³ (+5ç§’)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-shape shape-item">ğŸ›¡ï¸</div><span>ç„¡æ•µã‚·ãƒ¼ãƒ«ãƒ‰</span>
                </div>
                <div class="legend-item">
                    <div class="legend-shape shape-item">ğŸ•Šï¸</div><span>ç©ºä¸­å¾©å¸°</span>
                </div>
                <div class="legend-item">
                    <div class="legend-shape shape-item">ğŸª¶</div><span>ãƒ€ãƒ–ãƒ«ã‚¸ãƒ£ãƒ³ãƒ—</span>
                </div>
                <div class="legend-item">
                    <div class="legend-shape shape-item">â³</div><span>æ™‚ã®ç ‚æ™‚è¨ˆ</span>
                </div>
                <div class="legend-item">
                    <div class="legend-shape shape-item">ğŸ”¥</div><span>ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—</span>
                </div>
                <div class="legend-item">
                    <div class="legend-shape shape-ladder"></div><span>ãƒã‚·ã‚´</span>
                </div>

            </div>
        </div>
    </div>

    <div id="help-modal" class="modal-overlay">
        <div class="modal-content">
            <button id="close-help-modal" class="close-btn">&times;</button>
            <h2>ã‚²ãƒ¼ãƒ ã®éŠã³æ–¹</h2>
            <h3>æ“ä½œæ–¹æ³•</h3>
            <table style="width: 100%; text-align: left; border-collapse: collapse;">
                <thead style="border-bottom: 1px solid #7f8c8d;">
                    <tr>
                        <th style="padding: 8px;">æ“ä½œ</th>
                        <th style="padding: 8px;">ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰</th>
                        <th style="padding: 8px;">ã‚¹ãƒãƒ›</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td style="padding: 8px;">ç§»å‹•</td>
                        <td style="padding: 8px;">â† â†’ or A D</td>
                        <td style="padding: 8px;">â—€ â–¶</td>
                    </tr>
                    <tr>
                        <td style="padding: 8px;">ã‚¸ãƒ£ãƒ³ãƒ—/ãƒã‚·ã‚´ç™»ã‚‹</td>
                        <td style="padding: 8px;">ã‚¹ãƒšãƒ¼ã‚¹ or â†‘ or W</td>
                        <td style="padding: 8px;">â–²</td>
                    </tr>
                    <tr>
                        <td style="padding: 8px;">ã‚¢ã‚¯ã‚·ãƒ§ãƒ³(å°„æ’ƒ/æµ®éŠ)/å•†äººã¨å–å¼•</td>
                        <td style="padding: 8px;">å·¦Shift or X</td>
                        <td style="padding: 8px;">â—</td>
                    </tr>

                </tbody>
            </table>
            <h3>ã‚¹ã‚³ã‚¢ã«ã¤ã„ã¦</h3>
            <p>ãƒ»ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’å³ã«é€²ã‚€ã¨ã‚¹ã‚³ã‚¢ãŒå¢—ãˆã¾ã™ã€‚å¾Œé€€ã™ã‚‹ã¨ã‚¹ã‚³ã‚¢ãŒæ¸›å°‘ã—ã¾ã™ã€‚<br>
                ãƒ»æ•µã‚’å€’ã™ã¨ã‚¹ã‚³ã‚¢ãŒåŠ ç®—ã•ã‚Œã¾ã™ã€‚ï¼ˆ+50ç‚¹ï¼‰<br>
                ãƒ»ãƒœã‚¹ã‚’å€’ã™ã¨ã€ã‚ˆã‚Šå¤šãã®ã‚¹ã‚³ã‚¢ã‚’ç²å¾—ã§ãã¾ã™ã€‚<br>
                ãƒ»ã‚¢ã‚¤ãƒ†ãƒ ã®ä¸Šã«ã‚ã‚‹ã‚²ãƒ¼ã‚¸ã¯ãƒœã‚¹æˆ¦ã¾ã§ã®å‰é€²çŒ¶äºˆã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚</p>
            <h3>æ“ä½œã®ãƒ’ãƒ³ãƒˆ</h3>
            <p>ãƒ»ç”»é¢ã®ä¸­å¤®ã«ã‚ã‚‹ãƒ©ã‚¤ãƒ³ã‚ˆã‚Šä¸Šã‚’ç§»å‹•ã™ã‚‹ã¨ã€è¿½ã„é¢¨ã«ä¹—ã£ã¦<strong>ç§»å‹•ã‚¹ãƒ”ãƒ¼ãƒ‰ãŒå¤§å¹…ã«ã‚¢ãƒƒãƒ—</strong>ã—ã¾ã™ã€‚ã“ã‚Œã‚’åˆ©ç”¨ã—ã¦ä¸€æ°—ã«è·é›¢ã‚’ç¨¼ã„ã ã‚Šã€å±é™ºãªå ´æ‰€ã‚’ç´ æ—©ãçªç ´ã—ãŸã‚Šã§ãã¾ã™ã€‚</p>
            <h3>ã‚¢ã‚¤ãƒ†ãƒ ä¸€è¦§</h3>

            <ul>
                <li><strong>ğŸ›¡ï¸ ç„¡æ•µã‚·ãƒ¼ãƒ«ãƒ‰:</strong> æ•µã®æ”»æ’ƒã‚„æ£˜ã‹ã‚‰ä¸€åº¦ã ã‘èº«ã‚’å®ˆã‚Šã¾ã™ã€‚</li>
                <li><strong>ğŸ•Šï¸ ç©ºä¸­å¾©å¸°:</strong> ã‚¹ãƒ†ãƒ¼ã‚¸ã‹ã‚‰è½ä¸‹ã—ã¦ã—ã¾ã£ãŸæ™‚ã«ä¸€åº¦ã ã‘åŠ©ã‹ã‚Šã¾ã™ã€‚</li>
                <li><strong>ğŸª¶ ãƒ€ãƒ–ãƒ«ã‚¸ãƒ£ãƒ³ãƒ—:</strong> ç©ºä¸­ã§è¿½åŠ ã®ã‚¸ãƒ£ãƒ³ãƒ—ãŒå¯èƒ½ã«ãªã‚Šã¾ã™ã€‚</li>
                <li><strong>â³ æ™‚ã®ç ‚æ™‚è¨ˆ:</strong> ä¸€å®šæ™‚é–“ã€æ•µã‚„ã‚®ãƒŸãƒƒã‚¯ã®å‹•ãã‚’å®Œå…¨ã«æ­¢ã‚ã‚‰ã‚Œã€ãƒœã‚¹ã¨ã®æˆ¦é—˜ã‚‚å›é¿ã§ãã¾ã™ã€‚ç„¡æ•µã‚·ãƒ¼ãƒ«ãƒ‰ã‹ç©ºä¸­å¾©å¸°ãŒä½¿ç”¨ã•ã‚Œã‚‹ã¨è‡ªå‹•çš„ã«ç™ºå‹•ã—ã¾ã™ã€‚</li>
                <li><strong>ğŸ”¥ ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—:</strong>
                    ä¸€å®šæ™‚é–“ã€ãƒ•ã‚¡ã‚¤ã‚¢ãƒ»ã‚¢ã‚¤ã‚¹ã®å¼¾ãŒå¤§ãããªã‚Šã€æ”»æ’ƒåŠ›ã®ä¸Šæ˜‡ã¨å½“ãŸã£ã¦ã‚‚æ¶ˆãˆãªã„è²«é€šåŠ›ã‚’æŒã¡ã¾ã™ã€‚æµ®éŠã®å ´åˆã¯ä¸Šæ˜‡ãƒ»è½ä¸‹é€Ÿåº¦ä½ä¸‹ã®åŠ¹æœãŒé«˜ã¾ã‚Šã¾ã™ã€‚ç„¡æ•µã‚·ãƒ¼ãƒ«ãƒ‰ã‹ç©ºä¸­å¾©å¸°ãŒä½¿ç”¨ã•ã‚Œã‚‹ã¨è‡ªå‹•çš„ã«ç™ºå‹•ã—ã¾ã™ã€‚
                </li>
            </ul>

            <h3>ãƒ‰ãƒƒãƒˆçµµå·¥æˆ¿</h3>
            <p>å·¦ã®ãƒ‘ãƒãƒ«ã§ã¯ã€è‡ªåˆ†ã ã‘ã®ã‚ªãƒªã‚¸ãƒŠãƒ«ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’ä½œæˆã§ãã¾ã™ã€‚ã€Œã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã«é©ç”¨ã€ãƒœã‚¿ãƒ³ã§ã‚²ãƒ¼ãƒ ã«åæ˜ ã•ã‚Œã€ç”»åƒã®ç¸¦æ¨ªæ¯”ã‚„è‰²åˆã„ã«ã‚ˆã£ã¦ã€æ€§èƒ½ã‚„ç‰¹æ®Šèƒ½åŠ›ãŒå¤‰åŒ–ã—ã¾ã™ã€‚</p>
            <ul>
                <li><strong>æš–è‰²ç³»ãŒå¤šã„ç”»åƒ:</strong> ãƒ•ã‚¡ã‚¤ã‚¢ãƒœãƒ¼ãƒ«ã‚’æ’ƒã¦ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚æ•µã‚„ã‚®ãƒŸãƒƒã‚¯ã‚’ç ´å£Šã§ãã¾ã™ã€‚</li>
                <li><strong>å¯’è‰²ç³»ãŒå¤šã„ç”»åƒ:</strong> ã‚¢ã‚¤ã‚¹ãƒ–ãƒ­ãƒƒã‚¯ã‚’æ’ƒã¦ã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚æ•µã‚„ã‚®ãƒŸãƒƒã‚¯ã‚’å‡ã‚‰ã›ã¦è¶³å ´ã«ã§ãã¾ã™ã€‚ä¸€å®šæ™‚é–“ã§å‡çµãŒè§£é™¤ã•ã‚Œå¯¾è±¡ã¯æ¶ˆæ»…ã—ã¾ã™ã€‚</li>
                <li><strong>ãã‚Œä»¥å¤–ã®ç”»åƒ:</strong> åœ°ä¸Šã§ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ç¶šã‘ã‚‹ã“ã¨ã§ã€ç‡ƒæ–™ã‚’æ¶ˆè²»ã—ã¦ä¸Šæ˜‡ã—ç¶šã‘ã¾ã™ã€‚ç©ºä¸­ã§ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ç¶šã‘ã‚‹ã“ã¨ã§ã€ç‡ƒæ–™ã‚’æ¶ˆè²»ã—ã¦ã‚†ã£ãã‚Šä¸‹é™ã§ãã¾ã™ã€‚
                </li>
            </ul>

            <p>ãƒ‰ãƒƒãƒˆçµµå·¥æˆ¿ã®<strong>ã€Œã‚¹ãƒ­ãƒƒãƒˆ1ã€œ3ã¸ä¿å­˜ã€</strong>ãƒœã‚¿ãƒ³ã§ã€ä½œæˆã—ãŸã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’ä¿å­˜ã§ãã¾ã™ã€‚ä¿å­˜ã—ãŸã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã¯ã€ã‚²ãƒ¼ãƒ ç”»é¢ä¸‹ã®ã‚¹ãƒ­ãƒƒãƒˆã«ã‚µãƒ ãƒã‚¤ãƒ«è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚<br>
                ã‚²ãƒ¼ãƒ ä¸­ã«ã€å¯¾å¿œã™ã‚‹æ•°å­—ã‚­ãƒ¼ï¼ˆ1, 2,
                3ï¼‰ã‚’æŠ¼ã™ã‹ã€ç”»é¢ã®ã‚¹ãƒ­ãƒƒãƒˆãƒœã‚¿ãƒ³ã‚’ç›´æ¥ã‚¿ãƒƒãƒ—ã™ã‚‹ã“ã¨ã§ã€ãã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã«<strong>ç¬é–“çš„ã«å¤‰èº«</strong>ã§ãã¾ã™ã€‚çŠ¶æ³ã«å¿œã˜ã¦ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’åˆ‡ã‚Šæ›¿ãˆã€ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’æœ‰åˆ©ã«é€²ã‚ã¾ã—ã‚‡ã†ï¼</p>

            <h3>ãƒ“ãƒ¼ãƒˆã‚·ãƒ¼ã‚±ãƒ³ã‚µãƒ¼</h3>
            <p>ãƒ‰ãƒƒãƒˆçµµå·¥æˆ¿ã®ä¸‹ã«ã‚ã‚‹ã‚·ãƒ¼ã‚±ãƒ³ã‚µãƒ¼ã§ã€ã‚ªãƒªã‚¸ãƒŠãƒ«ã®BGMã‚’ä½œæˆã§ãã¾ã™ã€‚ã€Œå†ç”Ÿã€ã‚’æŠ¼ã™ã¨ã€ä½œæˆã—ãŸãƒ“ãƒ¼ãƒˆã«å¿œã˜ã¦ã‚²ãƒ¼ãƒ ã®é›£æ˜“åº¦ã¨ã‚¹ã‚³ã‚¢å€ç‡ãŒãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã§å¤‰åŒ–ã—ã¾ã™ã€‚</p>
            <ul>
                <li><strong>ãƒãƒ¼ãƒˆæ•°ãŒå¤šã„ã»ã©:</strong> å¼·åˆ¶ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãŒé€Ÿããªã‚Šã€ã‚¹ã‚³ã‚¢å€ç‡ã‚‚ä¸ŠãŒã‚Šã¾ã™ã€‚</li>
                <li><strong>BPMãŒé«˜ã„ã»ã©:</strong> å¼·åˆ¶ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ãŒã•ã‚‰ã«é€Ÿããªã‚Šã€ã‚¹ã‚³ã‚¢å€ç‡ã‚‚ã•ã‚‰ã«ä¸ŠãŒã‚Šã¾ã™ã€‚</li>
            </ul>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const GAME_WIDTH = 800; const GAME_HEIGHT = 600;
        canvas.width = GAME_WIDTH; canvas.height = GAME_HEIGHT;

        // â˜…â˜…â˜… ãƒœã‚¹è¨­å®šç”¨ã®å®šæ•° â˜…â˜…â˜…
        const BOSS_SPAWN_SCORE_INTERVAL = 5000;
        const BOSS_BASE_SIZE = 60;
        const BOSS_SIZE_INCREASE_PER_INTERVAL = 20;
        const BOSS_MIN_SIDES = 1;
        const BOSS_MAX_SIDES = 5;
        const BOSS_PART_SIZE = 25;
        const BOSS_BASE_SPEED = 0.5;
        const BOSS_ROTATION_SPEED = 0.005;
        const BOSS_PART_SHOOT_COOLDOWN_MIN = 150;
        const BOSS_PART_SHOOT_COOLDOWN_RANGE = 100;
        const BOSS_SCORE_PER_PART = 150;

        const player = {
            x: 100, y: 450, width: 30, height: 30, color: '#000000', velocityX: 0, velocityY: 0,
            baseSpeed: 4.5, baseJumpPower: 13, onGround: false, onLadder: false, angle: 0,
            shieldRescues: 0, fallRescues: 0, doubleJumps: 0, timeStops: 0, powerUps: 0,
            invincible: false, invincibleTimer: 0, poweredUp: false, powerUpTimer: 0,
            image: null, facing: 1, colorAbility: 'neutral', shotCooldown: 0, hoverFuel: 120,
            shotCooldownMax: { fire: 40, ice: 60 },
            isTrading: false, isGravityReversing: false, isHelpOpen: false,
            isAnimated: false,
            spriteSheet: null,
            frameCount: 0,
            currentFrame: 0,
            frameWidth: 0,
            frameHeight: 0,
            animationTimer: 0,
            animationSpeed: 10,
            characterSlots: [null, null, null]
        };

        const PLAYER_DEFAULT_WIDTH = 30;
        const PLAYER_DEFAULT_HEIGHT = 30;
        const PLAYER_MIN_SIZE = 15;
        const PLAYER_MAX_SIZE = 120;
        const HOVER_FUEL_MAX = 120;
        const COYOTE_TIME_FRAMES = 6;

        const keys = {};
        const gravity = 0.6; const windFactor = 3; const JUMP_PAD_BOOST = 1.5;
        const INITIAL_TIME = 120;
        const COIN_TIME_BONUS = 5;

        let platforms = [], obstacles = [], ladders = [], groundEnemies = [], airEnemies = [], jumpPads = [], timeCoins = [], shieldRescueItems = [], fallRescueItems = [], doubleJumpItems = [], turrets = [], playerProjectiles = [], enemyProjectiles = [], merchants = [], timeStopItems = [], powerUpItems = []; bossBeams = [];
        let boss = null, bossFightActive = false, nextBossScore = BOSS_SPAWN_SCORE_INTERVAL;
        let lastBossSides = 0;
        let scoreAtLastBossDefeat = 0;
        let bossDefeatCount = 0;
        let score = 0, lastPositionScore = 0, timeLeft = INITIAL_TIME, gameOver = false, cameraX = 0, frameCounter = 0;
        let jumpKeyPressedLastFrame = false, actionKeyPressedLastFrame = false;
        let isTimeFrozen = false, timeFreezeTimer = 0;

        // â˜…â˜…â˜… ã“ã“ã‹ã‚‰ãŒæ–°ã—ã„ã‚·ãƒ¼ã‚±ãƒ³ã‚µãƒ¼è¨­å®šã§ã™ â˜…â˜…â˜…
        let BPM = 120;
        const STEPS_PER_BEAT = 4;
        const TOTAL_STEPS = 16;
        let sequencerInterval = null;
        let currentStep = 0;
        let isPlaying = false;
        let forcedScrollSpeed = 0;
        let scoreMultiplier = 1.0;

        const PARTS = {
            // --- ä½éŸ³åŸŸã®ãƒªã‚ºãƒ  (ãƒ“ãƒ¼ãƒˆã®åœŸå°) ---
            KICK: { sound: { freq: 80, duration: 0.1, vol: 0.5, type: 'triangle', freqEnd: 40 }, pattern: Array(TOTAL_STEPS).fill(0) },
            SNARE: { sound: { freq: 250, duration: 0.1, vol: 0.3, type: 'square' }, pattern: Array(TOTAL_STEPS).fill(0) },

            // --- ä¸­éŸ³åŸŸã®ãƒ‘ãƒ¼ã‚«ãƒƒã‚·ãƒ§ãƒ³ (å½©ã‚Š) ---
            TOM: { sound: { freq: 180, duration: 0.15, vol: 0.4, type: 'sine', freqEnd: 100 }, pattern: Array(TOTAL_STEPS).fill(0) },
            CLAP: { sound: { freq: 600, duration: 0.1, vol: 0.2, type: 'square', freqEnd: 1000 }, pattern: Array(TOTAL_STEPS).fill(0) },

            // --- é«˜éŸ³åŸŸã®ãƒªã‚ºãƒ  (ã‚°ãƒ«ãƒ¼ãƒ´æ„Ÿ) ---
            HAT: { sound: { freq: 800, duration: 0.05, vol: 0.1, type: 'sawtooth', freqEnd: 1200 }, pattern: Array(TOTAL_STEPS).fill(0) },
            OPEN_HAT: { sound: { freq: 900, duration: 0.4, vol: 0.1, type: 'sawtooth', freqEnd: 1400 }, pattern: Array(TOTAL_STEPS).fill(0) },

            // --- éŸ³éšã®ã‚ã‚‹æ¥½å™¨ (éŸ³æ¥½ã®éª¨æ ¼) ---
            BASS: { sound: { freq: 120, duration: 0.1, vol: 0.3, type: 'sine', freqEnd: 100 }, pattern: Array(TOTAL_STEPS).fill(0) },
            LEAD_SYNTH: { sound: { freq: 440, duration: 0.1, vol: 0.3, type: 'sawtooth', freqEnd: 466 }, pattern: Array(TOTAL_STEPS).fill(0) },
        };
        // â˜…â˜…â˜… ã“ã“ã¾ã§ â˜…â˜…â˜…

        let audioCtx;
        let isAudioInitialized = false;
        function initAudio() {
            if (isAudioInitialized) return;
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                if (audioCtx.state === 'suspended') { audioCtx.resume(); }
                isAudioInitialized = true;
            } catch (e) { console.error("Web Audio API is not supported."); }
        }
        const sfx = { playSound: (freq, duration, vol, type, freqEnd = freq) => { if (!isAudioInitialized || !audioCtx) return; const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.connect(g); g.connect(audioCtx.destination); o.type = type; o.frequency.setValueAtTime(freq, audioCtx.currentTime); if (freq !== freqEnd) o.frequency.linearRampToValueAtTime(freqEnd, audioCtx.currentTime + duration); g.gain.setValueAtTime(vol, audioCtx.currentTime); g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration); o.start(audioCtx.currentTime); o.stop(audioCtx.currentTime + duration); }, jump: () => sfx.playSound(261, 0.1, 0.2, 'sine', 523), doubleJump: () => sfx.playSound(392, 0.1, 0.2, 'sine', 784), enemyDefeat: () => sfx.playSound(200, 0.15, 0.3, 'square', 50), shieldUse: () => sfx.playSound(880, 0.3, 0.3, 'triangle', 1200), fallUse: () => sfx.playSound(440, 0.5, 0.4, 'sawtooth', 1000), itemGet: () => sfx.playSound(523, 0.2, 0.3, 'triangle', 880), gameOver: () => sfx.playSound(300, 0.8, 0.4, 'sawtooth', 100), shootFire: (pitch = 150) => sfx.playSound(pitch, 0.1, 0.3, 'sawtooth', pitch - 50), shootIce: (pitch = 600) => sfx.playSound(pitch, 0.15, 0.2, 'sine', pitch + 200), enemyShoot: () => sfx.playSound(100, 0.1, 0.2, 'square'), trade: () => sfx.playSound(1046, 0.2, 0.4, 'sine', 1396), bossDefeat: () => sfx.playSound(130, 1.5, 0.5, 'sawtooth', 2000), powerUp: () => sfx.playSound(440, 0.4, 0.4, 'square', 1760), timeStop: () => sfx.playSound(1760, 0.4, 0.4, 'square', 440) };

        const pixelGrid = document.getElementById('pixel-grid');
        const colorPalette = document.getElementById('color-palette');
        const applyPixelArtBtn = document.getElementById('apply-pixel-art');
        const clearPixelGridBtn = document.getElementById('clear-pixel-grid');
        const savePixelArtBtn = document.getElementById('save-pixel-art');
        const PIXEL_GRID_SIZE = 32;
        let drawingColor = '#000000';
        let isDrawing = false;
        const colors = [
            '#FFFFFF', '#C3C3C3', '#585858', '#000000', '#FF4500', '#FFD700', '#9ACD32', '#008000',
            '#00CED1', '#1E90FF', '#0000CD', '#8A2BE2', '#C71585', '#FF1493', '#A52A2A', 'transparent'
        ];

        function updatePixelArtPreview() {
            // â˜…â˜…â˜… è¡¨ç¤ºã™ã‚‹HTMLè¦ç´ ã‚’å–å¾— â˜…â˜…â˜…
            const tendencyDisplay = document.getElementById('color-tendency-preview');
            const speedBonusDisplay = document.getElementById('speed-bonus-display');
            const jumpBonusDisplay = document.getElementById('jump-bonus-display');
            const bulletSizeDisplay = document.getElementById('bullet-size-display');
            const bulletSpeedDisplay = document.getElementById('bullet-speed-display');

            const tempCanvas = getPixelCanvas();
            const tempCtx = tempCanvas.getContext('2d');
            const imageData = tempCtx.getImageData(0, 0, PIXEL_GRID_SIZE, PIXEL_GRID_SIZE);
            const data = imageData.data;
            let hasDrawing = false, warm = 0, cool = 0, neutral = 0;
            let minX = PIXEL_GRID_SIZE, maxX = -1, minY = PIXEL_GRID_SIZE, maxY = -1;

            // è‰²ã®å‚¾å‘ã‚’åˆ†æ (å†…å®¹ã¯å¤‰æ›´ãªã—)
            for (let i = 0; i < data.length; i += 4) {
                if (data[i + 3] > 0) {
                    hasDrawing = true;
                    const x = (i / 4) % PIXEL_GRID_SIZE;
                    const y = Math.floor((i / 4) / PIXEL_GRID_SIZE);
                    minX = Math.min(minX, x); maxX = Math.max(maxX, x);
                    minY = Math.min(minY, y); maxY = Math.max(maxY, y);

                    const r = data[i], g = data[i + 1], b = data[i + 2];
                    const max = Math.max(r, g, b), min = Math.min(r, g, b);
                    const saturation = (max === 0) ? 0 : (max - min) / max;
                    if (saturation < 0.25 || (max - min) < 20) { neutral++; continue; }
                    let hue;
                    if (max === min) hue = 0;
                    else { switch (max) { case r: hue = (g - b) / (max - min); break; case g: hue = 2 + (b - r) / (max - min); break; case b: hue = 4 + (r - g) / (max - min); break; } hue *= 60; if (hue < 0) hue += 360; }
                    if (hue >= 315 || hue < 60) warm++; else if (hue >= 150 && hue < 255) cool++; else neutral++;
                }
            }

            // â˜…â˜…â˜… æç”»ãŒãªã„å ´åˆã¯ã€è¡¨ç¤ºã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«æˆ»ã™ â˜…â˜…â˜…
            if (!hasDrawing) {
                speedBonusDisplay.textContent = 'ã‚¹ãƒ”ãƒ¼ãƒ‰è£œæ­£: +0.00';
                jumpBonusDisplay.textContent = 'ã‚¸ãƒ£ãƒ³ãƒ—è£œæ­£: +0.00';
                bulletSizeDisplay.textContent = 'å¼¾ã‚µã‚¤ã‚º: 8.00';
                bulletSpeedDisplay.textContent = 'å¼¾é€Ÿ: 8.00';
                return;
            }

            // â˜…â˜…â˜… è‰²ã®å‚¾å‘ã‚’è¡¨ç¤º â˜…â˜…â˜…
            let colorAbilityText = '';
            if (warm > cool && warm > neutral) colorAbilityText = 'æš–è‰²ç³» (ãƒ•ã‚¡ã‚¤ã‚¢)';
            else if (cool > warm && cool > neutral) colorAbilityText = 'å¯’è‰²ç³» (ã‚¢ã‚¤ã‚¹)';
            else colorAbilityText = 'ä¸­é–“è‰² (æµ®éŠ)';
            tendencyDisplay.textContent = colorAbilityText;

            // â˜…â˜…â˜… æ€§èƒ½å¤‰åŒ–ã‚’è¨ˆç®—ã—ã¦è¡¨ç¤º â˜…â˜…â˜…
            const effectiveWidth = (maxX - minX + 1);
            const effectiveHeight = (maxY - minY + 1);
            const scale = PLAYER_MAX_SIZE / PIXEL_GRID_SIZE;
            const previewWidth = Math.max(PLAYER_MIN_SIZE, Math.min(effectiveWidth * scale, PLAYER_MAX_SIZE));
            const previewHeight = Math.max(PLAYER_MIN_SIZE, Math.min(effectiveHeight * scale, PLAYER_MAX_SIZE));

            const widthRatio = previewWidth / PLAYER_DEFAULT_WIDTH;
            const heightRatio = previewHeight / PLAYER_DEFAULT_HEIGHT;
            const speedBonus = Math.max(0, (widthRatio - 1) * 2.0);
            const jumpBonus = Math.max(0, (heightRatio - 1) * 3.0);

            const sizeRatio = (previewWidth * previewHeight) / (PLAYER_DEFAULT_WIDTH * PLAYER_DEFAULT_HEIGHT) || 1;
            const projectileSize = Math.max(4, Math.min(8 * sizeRatio, 16));
            const projectileSpeed = Math.max(4, Math.min(12 / sizeRatio, 16));

            speedBonusDisplay.textContent = `ã‚¹ãƒ”ãƒ¼ãƒ‰è£œæ­£: +${speedBonus.toFixed(2)}`;
            jumpBonusDisplay.textContent = `ã‚¸ãƒ£ãƒ³ãƒ—è£œæ­£: +${jumpBonus.toFixed(2)}`;
            bulletSizeDisplay.textContent = `å¼¾ã‚µã‚¤ã‚º: ${projectileSize.toFixed(2)}`;
            bulletSpeedDisplay.textContent = `å¼¾é€Ÿ: ${projectileSpeed.toFixed(2)}`;
        }

        function initPixelEditor() {
            pixelGrid.innerHTML = '';
            colorPalette.innerHTML = '';

            // â˜…â˜…â˜… ã‚¿ãƒƒãƒä½ç½®ã‹ã‚‰å¯¾å¿œã™ã‚‹ã‚»ãƒ«ã‚’è¦‹ã¤ã‘ã‚‹é–¢æ•° â˜…â˜…â˜…
            const getCellFromTouch = (touch) => {
                const target = document.elementFromPoint(touch.clientX, touch.clientY);
                if (target && target.classList.contains('pixel-cell')) {
                    return target;
                }
                return null;
            };

            // 1. ãƒ”ã‚¯ã‚»ãƒ«ã‚°ãƒªãƒƒãƒ‰ã‚’ç”Ÿæˆ
            for (let i = 0; i < PIXEL_GRID_SIZE * PIXEL_GRID_SIZE; i++) {
                const cell = document.createElement('div');
                cell.classList.add('pixel-cell');

                // --- ãƒã‚¦ã‚¹æ“ä½œ ---
                cell.addEventListener('mousedown', (e) => {
                    isDrawing = true;
                    cell.style.backgroundColor = drawingColor;
                    updatePixelArtPreview();
                });
                cell.addEventListener('mouseover', (e) => {
                    if (isDrawing) {
                        cell.style.backgroundColor = drawingColor;
                        updatePixelArtPreview();
                    }
                });
                pixelGrid.appendChild(cell);
            }

            // --- ãƒã‚¦ã‚¹ã¨ã‚¿ãƒƒãƒã®æç”»çµ‚äº†å‡¦ç† ---
            document.body.addEventListener('mouseup', () => isDrawing = false);
            document.body.addEventListener('touchend', () => isDrawing = false);
            pixelGrid.addEventListener('mouseleave', () => isDrawing = false);

            // â˜…â˜…â˜… ã“ã“ã‹ã‚‰ãŒã‚¿ãƒƒãƒæ“ä½œå¯¾å¿œã®è¿½åŠ éƒ¨åˆ† â˜…â˜…â˜…
            let lastTouchedCell = null;
            pixelGrid.addEventListener('touchstart', (e) => {
                e.preventDefault(); // ç”»é¢ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’é˜²ã
                isDrawing = true;
                const cell = getCellFromTouch(e.touches[0]);
                if (cell) {
                    cell.style.backgroundColor = drawingColor;
                    lastTouchedCell = cell;
                    updatePixelArtPreview();
                }
            }, { passive: false });

            pixelGrid.addEventListener('touchmove', (e) => {
                e.preventDefault(); // ç”»é¢ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’é˜²ã
                if (isDrawing) {
                    const cell = getCellFromTouch(e.touches[0]);
                    // åŒã˜ã‚»ãƒ«ã‚’ä½•åº¦ã‚‚å¡—ã‚Šã¤ã¶ã•ãªã„ã‚ˆã†ã«ãƒã‚§ãƒƒã‚¯
                    if (cell && cell !== lastTouchedCell) {
                        cell.style.backgroundColor = drawingColor;
                        lastTouchedCell = cell;
                        updatePixelArtPreview();
                    }
                }
            }, { passive: false });

            // 2. ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆã‚’ç”Ÿæˆã™ã‚‹
            colors.forEach(color => {
                const swatch = document.createElement('div');
                swatch.classList.add('color-swatch');

                // ã€Œé€æ˜ã€è‰²ã®å ´åˆã¯ç‰¹åˆ¥ãªèƒŒæ™¯ç”»åƒã‚’è¨­å®š
                if (color === 'transparent') {
                    swatch.style.background = 'url("data:image/svg+xml,%3Csvg xmlns=\'http://www.w.org/2000/svg\' width=\'10\' height=\'10\'%3E%3Crect width=\'10\' height=\'10\' fill=\'white\'/%3E%3Cpath d=\'M0 0 L10 10 M10 0 L0 10\' stroke=\'red\' stroke-width=\'2\'/%3E%3C/svg%3E")';
                } else {
                    swatch.style.backgroundColor = color;
                }

                if (color === drawingColor) swatch.classList.add('active');

                // ãƒ‘ãƒ¬ãƒƒãƒˆã®è‰²ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ãŸæ™‚ã«ã€é¸æŠè‰²ã‚’å¤‰æ›´ã—ã€ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’æ›´æ–°ã™ã‚‹
                swatch.addEventListener('click', () => {
                    drawingColor = color;
                    document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                    swatch.classList.add('active');
                    updatePixelArtPreview(); // â˜…â˜…â˜… ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ›´æ–°ã‚’è¿½åŠ  â˜…â˜…â˜…
                });
                colorPalette.appendChild(swatch);
            });

            // 3. ã€Œå…¨æ¶ˆå»ã€ãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¨­å®šã™ã‚‹
            //    (å…ƒã®å ´æ‰€ã‹ã‚‰ã“ã“ã«ç§»å‹•ã•ã›ã€ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ›´æ–°æ©Ÿèƒ½ã‚’è¿½åŠ )
            clearPixelGridBtn.addEventListener('click', () => {
                document.querySelectorAll('.pixel-cell').forEach(cell => cell.style.backgroundColor = 'transparent');
                updatePixelArtPreview(); // â˜…â˜…â˜… ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ›´æ–°ã‚’è¿½åŠ  â˜…â˜…â˜…
            });

            // 4. é–¢æ•°ã®æœ€å¾Œã«ã€åˆæœŸçŠ¶æ…‹ã®ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’ä¸€åº¦è¡¨ç¤ºã™ã‚‹
            updatePixelArtPreview(); // â˜…â˜…â˜… åˆæœŸè¡¨ç¤ºã®ãŸã‚ã«è¿½åŠ  â˜…â˜…â˜…
        }

        clearPixelGridBtn.addEventListener('click', () => { document.querySelectorAll('.pixel-cell').forEach(cell => cell.style.backgroundColor = 'transparent'); });

        function getPixelCanvas() {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = PIXEL_GRID_SIZE; tempCanvas.height = PIXEL_GRID_SIZE;
            const tempCtx = tempCanvas.getContext('2d');
            const cells = document.querySelectorAll('.pixel-cell');
            cells.forEach((cell, i) => {
                const x = i % PIXEL_GRID_SIZE;
                const y = Math.floor(i / PIXEL_GRID_SIZE);
                tempCtx.fillStyle = cell.style.backgroundColor || 'transparent';
                tempCtx.fillRect(x, y, 1, 1);
            });
            return tempCanvas;
        }

        function updatePlayerStats() {
            const widthRatio = player.width / PLAYER_DEFAULT_WIDTH;
            const heightRatio = player.height / PLAYER_DEFAULT_HEIGHT;
            const speedBonus = Math.max(0, (widthRatio - 1) * 2.0);
            const jumpBonus = Math.max(0, (heightRatio - 1) * 3.0);
            player.speed = player.baseSpeed + speedBonus;
            player.jumpPower = player.baseJumpPower + jumpBonus;

            const sizeRatio = (player.width * player.height) / (PLAYER_DEFAULT_WIDTH * PLAYER_DEFAULT_HEIGHT) || 1;
            const projectileSize = Math.max(4, Math.min(8 * sizeRatio, 16));
            const projectileSpeed = Math.max(4, Math.min(12 / sizeRatio, 16));

            // â˜…â˜…â˜…â˜…â˜… ã“ã‚ŒãŒã€æŠœã‘è½ã¡ã¦ã„ãŸæ ¹æœ¬åŸå› ã®ä¿®æ­£ã§ã™ï¼ â˜…â˜…â˜…â˜…â˜…
            // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚µã‚¤ã‚ºã«å¿œã˜ã¦ã€å°„æ’ƒé–“éš”ã‚’å†è¨ˆç®—ã—ã¾ã™ã€‚
            // ã“ã‚Œã«ã‚ˆã‚Šã€ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã‚¿ã‚¤ãƒãƒ¼ãŒå¸¸ã«æœ‰åŠ¹ãªæ•°å€¤ã«ãªã‚Šã¾ã™ã€‚
            player.shotCooldownMax = { fire: 40 * sizeRatio, ice: 60 * sizeRatio };
            player.hoverFuelMax = HOVER_FUEL_MAX * sizeRatio;
            player.hoverRefillRate = 1 / sizeRatio;

            document.getElementById('speed-bonus-display').textContent = `ã‚¹ãƒ”ãƒ¼ãƒ‰è£œæ­£: +${speedBonus.toFixed(2)}`;
            document.getElementById('jump-bonus-display').textContent = `ã‚¸ãƒ£ãƒ³ãƒ—è£œæ­£: +${jumpBonus.toFixed(2)}`;
            document.getElementById('bullet-size-display').textContent = `å¼¾ã‚µã‚¤ã‚º: ${projectileSize.toFixed(2)}`;
            document.getElementById('bullet-speed-display').textContent = `å¼¾é€Ÿ: ${projectileSpeed.toFixed(2)}`;
        }

function analyzeAndApplyImage(source, applyToPlayer = true) { // â˜…â˜…â˜… å¼•æ•°åã‚’ img ã‹ã‚‰ source ã«å¤‰æ›´
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            // â˜…â˜…â˜… source ã®å¹…ã¨é«˜ã•ã‚’æ­£ã—ãå–å¾—ã™ã‚‹ã‚ˆã†ã«å¤‰æ›´ â˜…â˜…â˜…
            tempCanvas.width = source.width;
            tempCanvas.height = source.height;
            tempCtx.drawImage(source, 0, 0); // â˜…â˜…â˜… imageã§ã‚‚canvasã§ã‚‚æç”»ã§ãã‚‹
            let tendency = 'neutral';
            try {
                // â˜…â˜…â˜… ã“ã“ã‚’ img ã‹ã‚‰ source ã«ä¿®æ­£ï¼ â˜…â˜…â˜…
                const imageData = tempCtx.getImageData(0, 0, source.width, source.height);
                const data = imageData.data;
                let warm = 0, cool = 0, neutral = 0;
                for (let i = 0; i < data.length; i += 4) {
                    if (data[i + 3] < 128) continue;
                    const r = data[i], g = data[i + 1], b = data[i + 2];
                    const max = Math.max(r, g, b), min = Math.min(r, g, b);
                    const saturation = (max === 0) ? 0 : (max - min) / max;
                    if (saturation < 0.25 || (max - min) < 20) { neutral++; continue; }
                    let hue;
                    if (max === min) { hue = 0; }
                    else { switch (max) { case r: hue = (g - b) / (max - min); break; case g: hue = 2 + (b - r) / (max - min); break; case b: hue = 4 + (r - g) / (max - min); break; } hue *= 60; if (hue < 0) hue += 360; }
                    if (hue >= 315 || hue < 60) warm++; else if (hue >= 150 && hue < 255) cool++; else neutral++;
                }
                if (warm > cool && warm > neutral) tendency = 'warm';
                else if (cool > warm && cool > neutral) tendency = 'cool';
            } catch (e) {
                console.warn("Could not analyze image colors. Defaulting to neutral.");
            }

            if (applyToPlayer) {
                player.colorAbility = tendency;
            }
            return tendency; // â˜…â˜…â˜… åˆ†æçµæœã‚’æ–‡å­—åˆ—ã¨ã—ã¦è¿”ã™ï¼ â˜…â˜…â˜…
        }

        applyPixelArtBtn.addEventListener('click', () => {
            initAudio();
            const animationMode = document.querySelector('input[name="anim-mode"]:checked').value;
            const tempCanvas = getPixelCanvas();

            player.isAnimated = false;
            player.spriteSheet = null;
            player.image = null;

            const tempCtx = tempCanvas.getContext('2d');
            const imageData = tempCtx.getImageData(0, 0, PIXEL_GRID_SIZE, PIXEL_GRID_SIZE);
            const data = imageData.data;
            let minX_total = PIXEL_GRID_SIZE, maxX_total = -1, minY_total = PIXEL_GRID_SIZE, maxY_total = -1;
            let hasDrawing = false;
            for (let i = 0; i < data.length; i += 4) {
                if (data[i + 3] > 0) {
                    hasDrawing = true;
                    const x = (i / 4) % PIXEL_GRID_SIZE;
                    const y = Math.floor((i / 4) / PIXEL_GRID_SIZE);
                    minX_total = Math.min(minX_total, x); maxX_total = Math.max(maxX_total, x);
                    minY_total = Math.min(minY_total, y); maxY_total = Math.max(maxY_total, y);
                }
            }
            if (!hasDrawing) return;

            const oldHeight = player.height;
            let finalWidth, finalHeight;

            if (animationMode === 'none') {
                const effectiveWidth = (maxX_total - minX_total + 1);
                const effectiveHeight = (maxY_total - minY_total + 1);
                const scale = PLAYER_MAX_SIZE / PIXEL_GRID_SIZE;
                finalWidth = Math.max(PLAYER_MIN_SIZE, Math.min(effectiveWidth * scale, PLAYER_MAX_SIZE));
                finalHeight = Math.max(PLAYER_MIN_SIZE, Math.min(effectiveHeight * scale, PLAYER_MAX_SIZE));
            } else {
                player.isAnimated = true;

                // â˜…â˜…â˜… ã“ã“ã‹ã‚‰ãŒä¿®æ­£ç®‡æ‰€ã§ã™ â˜…â˜…â˜…
                const cols = (animationMode === '6frames') ? 3 : (animationMode === '4frames') ? 2 : 1;
                const rows = 2;
                player.frameCount = cols * rows;

                let maxFramePixelWidth = 0;
                let maxFramePixelHeight = 0;

                const colWidths = (cols === 3) ? [11, 11, 10] : (cols === 2) ? [16, 16] : [32];
                const rowHeights = [16, 16];
                const colStarts = (cols === 3) ? [0, 11, 22] : (cols === 2) ? [0, 16] : [0];
                const rowStarts = [0, 16];
                // â˜…â˜…â˜… ã“ã“ã¾ã§ãŒä¿®æ­£ç®‡æ‰€ã§ã™ â˜…â˜…â˜…

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const cellStartX = colStarts[c];
                        const cellStartY = rowStarts[r];
                        const cellWidth = colWidths[c];
                        const cellHeight = rowHeights[r];

                        let minX_frame = PIXEL_GRID_SIZE, maxX_frame = -1, minY_frame = PIXEL_GRID_SIZE, maxY_frame = -1;
                        let hasDrawingInFrame = false;

                        for (let y = cellStartY; y < cellStartY + cellHeight; y++) {
                            for (let x = cellStartX; x < cellStartX + cellWidth; x++) {
                                const i = (y * PIXEL_GRID_SIZE + x) * 4;
                                if (data[i + 3] > 0) {
                                    hasDrawingInFrame = true;
                                    minX_frame = Math.min(minX_frame, x);
                                    maxX_frame = Math.max(maxX_frame, x);
                                    minY_frame = Math.min(minY_frame, y);
                                    maxY_frame = Math.max(maxY_frame, y);
                                }
                            }
                        }

                        if (hasDrawingInFrame) {
                            const frameContentWidth = maxX_frame - minX_frame + 1;
                            const frameContentHeight = maxY_frame - minY_frame + 1;
                            maxFramePixelWidth = Math.max(maxFramePixelWidth, frameContentWidth);
                            maxFramePixelHeight = Math.max(maxFramePixelHeight, frameContentHeight);
                        }
                    }
                }

                player.frameWidth = Math.ceil((maxX_total - minX_total + 1) / cols);
                player.frameHeight = Math.ceil((maxY_total - minY_total + 1) / rows);

                const scale = PLAYER_MAX_SIZE / (PIXEL_GRID_SIZE / Math.max(cols, rows));
                finalWidth = Math.max(PLAYER_MIN_SIZE, Math.min(maxFramePixelWidth * scale, PLAYER_MAX_SIZE));
                finalHeight = Math.max(PLAYER_MIN_SIZE, Math.min(maxFramePixelHeight * scale, PLAYER_MAX_SIZE));
            }

            player.width = finalWidth;
            player.height = finalHeight;
            player.y -= (player.height - oldHeight);

            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = (maxX_total - minX_total + 1);
            finalCanvas.height = (maxY_total - minY_total + 1);
            finalCanvas.getContext('2d').drawImage(tempCanvas, minX_total, minY_total, finalCanvas.width, finalCanvas.height, 0, 0, finalCanvas.width, finalCanvas.height);

            const img = new Image();
            img.onload = () => {
                if (player.isAnimated) {
                    player.spriteSheet = img;
                } else {
                    player.image = img;
                }
                updatePlayerStats();
                analyzeAndApplyImage(img, true);
                player.shotCooldown = 0;
                player.hoverFuel = player.hoverFuelMax;
            };
            img.src = finalCanvas.toDataURL();
        });
        savePixelArtBtn.addEventListener('click', () => {
            // â˜…â˜…â˜… ãƒ•ã‚¡ã‚¤ãƒ«åã®å…¥åŠ›ã‚’æ±‚ã‚ã‚‹ â˜…â˜…â˜…
            const filename = window.prompt("PNGãƒ•ã‚¡ã‚¤ãƒ«åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:", "my-character");

            // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ãŸã‹ã€åå‰ãŒç©ºãªã‚‰å‡¦ç†ã‚’ä¸­æ–­
            if (!filename) {
                return;
            }

            // ãƒ•ã‚¡ã‚¤ãƒ«åã«ä½¿ãˆãªã„æ–‡å­—ã‚’ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã«ç½®æ›ï¼ˆå®‰å…¨å¯¾ç­–ï¼‰
            const safeFilename = filename.replace(/[\/\\:*?"<>|]/g, '_');

            const tempCanvas = getPixelCanvas();
            const link = document.createElement('a');
            // â˜…â˜…â˜… å…¥åŠ›ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«åã‚’è¨­å®šï¼ˆæ‹¡å¼µå­.pngã‚’è¿½åŠ ï¼‰ â˜…â˜…â˜…
            link.download = `${safeFilename}.png`;
            link.href = tempCanvas.toDataURL();
            link.click();
        });

        document.addEventListener('keydown', (e) => { initAudio(); keys[e.code] = true; });
        document.addEventListener('keyup', (e) => { keys[e.code] = false; });
        const gameOverScreen = document.getElementById('game-over-screen');
        gameOverScreen.addEventListener('click', (e) => { initAudio(); if (e.target.tagName !== 'A') init(); });
        const btnLeft = document.getElementById('btn-left'); const btnRight = document.getElementById('btn-right'); const btnJump = document.getElementById('btn-jump'); const btnAction = document.getElementById('btn-action');
        // --- å…±é€šã®ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†ã‚’å®šç¾© ---
        const pressLeft = (e) => { e.preventDefault(); initAudio(); keys['KeyA'] = true; };
        const releaseLeft = (e) => { e.preventDefault(); keys['KeyA'] = false; };
        const pressRight = (e) => { e.preventDefault(); initAudio(); keys['KeyD'] = true; };
        const releaseRight = (e) => { e.preventDefault(); keys['KeyD'] = false; };
        const pressJump = (e) => { e.preventDefault(); initAudio(); keys['Space'] = true; };
        const releaseJump = (e) => { e.preventDefault(); keys['Space'] = false; };
        const pressAction = (e) => { e.preventDefault(); initAudio(); keys['ShiftLeft'] = true; };
        const releaseAction = (e) => { e.preventDefault(); keys['ShiftLeft'] = false; };

        // --- å„ãƒœã‚¿ãƒ³ã«ã‚¿ãƒƒãƒã¨ãƒã‚¦ã‚¹ã®ä¸¡æ–¹ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’å‰²ã‚Šå½“ã¦ ---
        btnLeft.addEventListener('touchstart', pressLeft); btnLeft.addEventListener('touchend', releaseLeft);
        btnLeft.addEventListener('mousedown', pressLeft); btnLeft.addEventListener('mouseup', releaseLeft);
        btnLeft.addEventListener('mouseleave', releaseLeft); // ãƒœã‚¿ãƒ³ã‹ã‚‰ãƒã‚¦ã‚¹ãŒé›¢ã‚ŒãŸæ™‚ã‚‚é›¢ã—ãŸåˆ¤å®šã«ã™ã‚‹

        btnRight.addEventListener('touchstart', pressRight); btnRight.addEventListener('touchend', releaseRight);
        btnRight.addEventListener('mousedown', pressRight); btnRight.addEventListener('mouseup', releaseRight);
        btnRight.addEventListener('mouseleave', releaseRight);

        btnJump.addEventListener('touchstart', pressJump); btnJump.addEventListener('touchend', releaseJump);
        btnJump.addEventListener('mousedown', pressJump); btnJump.addEventListener('mouseup', releaseJump);
        btnJump.addEventListener('mouseleave', releaseJump);

        btnAction.addEventListener('touchstart', pressAction); btnAction.addEventListener('touchend', releaseAction);
        btnAction.addEventListener('mousedown', pressAction); btnAction.addEventListener('mouseup', releaseAction);
        btnAction.addEventListener('mouseleave', releaseAction);

        const imageUploader = document.getElementById('player-image-upload');
        imageUploader.addEventListener('change', (e) => {
            initAudio();
            if (e.target.files && e.target.files[0]) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        const originalWidth = img.naturalWidth; const originalHeight = img.naturalHeight;
                        const aspectRatio = originalWidth / originalHeight;
                        const oldHeight = player.height;
                        let newWidth, newHeight;
                        if (originalWidth > originalHeight) {
                            newWidth = Math.max(PLAYER_MIN_SIZE, Math.min(originalWidth, PLAYER_MAX_SIZE)); newHeight = newWidth / aspectRatio;
                        } else { newHeight = Math.max(PLAYER_MIN_SIZE, Math.min(originalHeight, PLAYER_MAX_SIZE)); newWidth = newHeight * aspectRatio; }
                        player.width = Math.max(PLAYER_MIN_SIZE, Math.min(newWidth, PLAYER_MAX_SIZE));
                        player.height = Math.max(PLAYER_MIN_SIZE, Math.min(newHeight, PLAYER_MAX_SIZE));
                        player.y -= (player.height - oldHeight);
                        player.image = img;
                        updatePlayerStats();
                        analyzeAndApplyImage(img);
                        player.shotCooldown = 0; // ãƒ•ã‚¡ã‚¤ã‚¢/ã‚¢ã‚¤ã‚¹ã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ã‚’ãƒªã‚»ãƒƒãƒˆ
                        player.hoverFuel = player.hoverFuelMax; // æµ®éŠã®ç‡ƒæ–™ã‚’æœ€å¤§ã¾ã§å›å¾©
                    }
                    img.src = event.target.result;
                }
                reader.readAsDataURL(e.target.files[0]);
            }
        });

        const resetImageBtn = document.getElementById('reset-image-btn');
        resetImageBtn.addEventListener('click', () => {
            initAudio();
            const oldHeight = player.height;
            player.image = null;
            player.width = PLAYER_DEFAULT_WIDTH;
            player.height = PLAYER_DEFAULT_HEIGHT;
            player.y -= (player.height - oldHeight);
            imageUploader.value = null;
            updatePlayerStats();
            player.colorAbility = 'neutral';
            player.shotCooldown = 0;
            player.hoverFuel = player.hoverFuelMax;
        });

        function generateWorld() {
            // â˜…â˜…â˜… ãƒœã‚¹æˆ¦æ™‚ã®ã‚¹ãƒ†ãƒ¼ã‚¸ç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯ â˜…â˜…â˜…
            if (bossFightActive) {
                // STEP 1: ãƒœã‚¹æˆ¦ç”¨ã®è¶…ã‚·ãƒ“ã‚¢ãªå‡ºç¾ç‡è£œæ­£ã‚’è¨ˆç®—
                const bossSpawnRateModifier = Math.max(0.05, 1.0 - (forcedScrollSpeed / 5.0) * 0.95);

                const cleanup = (arr) => arr.filter(o => o.x + (o.width || o.radius * 2) > cameraX - GAME_WIDTH);
                platforms = cleanup(platforms); merchants = cleanup(merchants);
                shieldRescueItems = cleanup(shieldRescueItems); fallRescueItems = cleanup(fallRescueItems);
                doubleJumpItems = cleanup(doubleJumpItems); timeStopItems = cleanup(timeStopItems);
                powerUpItems = cleanup(powerUpItems); timeCoins = cleanup(timeCoins);

                let lastPlatformX = 0;
                if (platforms.length > 0) { lastPlatformX = Math.max(...platforms.map(p => p.x + p.width)); }

                while (lastPlatformX < cameraX + GAME_WIDTH * 1.5) {
                    const newX = lastPlatformX;
                    const platformWidth = 400;

                    // 20%ã®ç¢ºç‡ã§è¶³å ´ã«ç©´ã‚’ã‚ã‘ã‚‹
                    if (Math.random() < 0.2) {
                        const gapWidth = Math.random() * 100 + 120; // ç©´ã®å¹…ã‚’åºƒã
                        const firstPartWidth = (platformWidth - gapWidth) / 2;
                        platforms.push({ x: newX, y: GAME_HEIGHT - 40, width: firstPartWidth, height: 20, type: 'normal' });
                        platforms.push({ x: newX + firstPartWidth + gapWidth, y: GAME_HEIGHT - 40, width: firstPartWidth, height: 20, type: 'normal' });
                    } else {
                        platforms.push({ x: newX, y: GAME_HEIGHT - 40, width: platformWidth, height: 20, type: 'normal' });
                    }

                    // STEP 2: å…¨ã¦ã®å‡ºç¾åˆ¤å®šã«ã€è¨ˆç®—ã—ãŸè£œæ­£å€¤ã‚’æ›ã‘åˆã‚ã›ã‚‹
                    if (Math.random() < 0.1 * bossSpawnRateModifier) merchants.push({ x: newX + 180, y: GAME_HEIGHT - 80, width: 40, height: 40 });
                    if (Math.random() < 0.05 * bossSpawnRateModifier) shieldRescueItems.push({ x: newX + Math.random() * 300, y: GAME_HEIGHT - 80, radius: 12 });
                    if (Math.random() < 0.05 * bossSpawnRateModifier) fallRescueItems.push({ x: newX + Math.random() * 300, y: GAME_HEIGHT - 80, radius: 12 });
                    if (Math.random() < 0.05 * bossSpawnRateModifier) doubleJumpItems.push({ x: newX + Math.random() * 300, y: GAME_HEIGHT - 80, radius: 12 });
                    if (Math.random() < 0.05 * bossSpawnRateModifier) timeStopItems.push({ x: newX + Math.random() * 300, y: GAME_HEIGHT - 80, radius: 12 });
                    if (Math.random() < 0.05 * bossSpawnRateModifier) powerUpItems.push({ x: newX + Math.random() * 300, y: GAME_HEIGHT - 80, radius: 12 });
                    if (Math.random() < 0.15 * bossSpawnRateModifier) { timeCoins.push({ x: newX + Math.random() * 300, y: GAME_HEIGHT - 80, radius: 10 }); }

                    lastPlatformX += platformWidth;
                }
                return; // ãƒœã‚¹æˆ¦ä¸­ã®å‡¦ç†ã¯ã“ã“ã¾ã§
            }

            // â˜…â˜…â˜… é€šå¸¸æ™‚ã®ã‚¹ãƒ†ãƒ¼ã‚¸ç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯ â˜…â˜…â˜…
            let occupiedSpaces = [];
            const isOccupied = (x, width) => {
                for (const space of occupiedSpaces) {
                    if (x < space.x + space.width && x + width > space.x) { return true; }
                }
                return false;
            };

            const cleanup = (arr) => arr.filter(o => o.x + (o.width || o.radius * 2) > cameraX - GAME_WIDTH * 2);
            platforms = cleanup(platforms); obstacles = cleanup(obstacles); ladders = cleanup(ladders);
            merchants = cleanup(merchants);
            const enemyCleanup = (arr) => arr.filter(e => e.x + (e.width || e.radius * 2) > cameraX - GAME_WIDTH * 2);
            groundEnemies = enemyCleanup(groundEnemies); airEnemies = enemyCleanup(airEnemies);
            turrets = enemyCleanup(turrets); enemyProjectiles = enemyCleanup(enemyProjectiles);
            timeCoins = cleanup(timeCoins); shieldRescueItems = cleanup(shieldRescueItems); fallRescueItems = cleanup(fallRescueItems); doubleJumpItems = cleanup(doubleJumpItems); timeStopItems = cleanup(timeStopItems); powerUpItems = cleanup(powerUpItems);
            playerProjectiles = cleanup(playerProjectiles);

            let lastGeneratedX = 0;
            [...platforms, ...jumpPads, ...ladders].forEach(p => { if (p.x + p.width > lastGeneratedX) lastGeneratedX = p.x + p.width; });

            while (lastGeneratedX < cameraX + GAME_WIDTH) {
                // STEP 1: é€šå¸¸æ™‚ç”¨ã®å‡ºç¾ç‡è£œæ­£ã‚’è¨ˆç®—
                const speedBasedModifier = Math.max(0.2, 1.0 - (forcedScrollSpeed / 5.0) * 0.8);

                const newAreaStartX = lastGeneratedX + (Math.random() * 150 + 100);
                let generatedHighPlatform = null, generatedLowPlatform = null;

                // --- ä½ã„è¶³å ´ã®ç”Ÿæˆ ---
                if (Math.random() < 0.95) {
                    const width = Math.random() * 180 + 120; const y = GAME_HEIGHT - (Math.random() * 100 + 60);
                    const platformType = Math.random();
                    if (platformType < 0.15) platforms.push({ x: newAreaStartX, y, width, height: 20, type: 'fragile', state: 'stable', timer: 45 });
                    else if (platformType < 0.3) platforms.push({ x: newAreaStartX, y, width, height: 20, type: 'moving_h', originalX: newAreaStartX, moveSpeed: 1, moveRange: 100, moveDir: 1 });
                    else platforms.push({ x: newAreaStartX, y, width, height: 20, type: 'normal' });
                    generatedLowPlatform = platforms[platforms.length - 1];

                    if (Math.random() < 0.4) {
                        const x = generatedLowPlatform.x + width / 2 - 15;
                        const w = 30;
                        if (!isOccupied(x, w)) { jumpPads.push({ x: x, y: y - 10, width: w, height: 10 }); occupiedSpaces.push({ x: x, width: w }); }
                    }
                    // STEP 2: å‡ºç¾åˆ¤å®šã«è£œæ­£å€¤ã‚’é©ç”¨
                    if (Math.random() < 0.1 * speedBasedModifier) {
                        const x = generatedLowPlatform.x + width * Math.random();
                        const w = 24;
                        if (!isOccupied(x - w / 2, w)) { shieldRescueItems.push({ x: x, y: y - 40, radius: 12 }); occupiedSpaces.push({ x: x - w / 2, width: w }); }
                    }
                    if (Math.random() < 0.25) {
                        const x = generatedLowPlatform.x + 20, w = 20;
                        if (!isOccupied(x, w)) { groundEnemies.push({ x, y: y - 20, width: w, height: 20, vx: 1, moveRange: width - 40, initialX: x }); occupiedSpaces.push({ x, width: w }); }
                    }
                    if (Math.random() < 0.25) {
                        const x = newAreaStartX + width / 2, w = 25;
                        if (!isOccupied(x, w)) { airEnemies.push({ x, y: y - 80, width: w, height: 25, vy: 1, moveRange: 60, initialY: y - 80 }); occupiedSpaces.push({ x, width: w }); }
                    }
                    if (Math.random() < 0.15) {
                        const x = generatedLowPlatform.x + width / 2 - 15, w = 30;
                        if (!isOccupied(x, w)) { turrets.push({ x, y: y - 30, width: w, height: 30, type: 'cannon', cooldown: 180 }); occupiedSpaces.push({ x, width: w }); }
                    }
                    // STEP 2: å‡ºç¾åˆ¤å®šã«è£œæ­£å€¤ã‚’é©ç”¨
                    if (Math.random() < 0.2 * speedBasedModifier) {
                        const x = newAreaStartX + width / 2 - 20, w = 40;
                        if (!isOccupied(x, w)) { merchants.push({ x, y: y - 40, width: w, height: 40 }); occupiedSpaces.push({ x, width: w }); }
                    }
                }

                // --- é«˜ã„è¶³å ´ã®ç”Ÿæˆ ---
                if (Math.random() < 0.95) {
                    const width = Math.random() * 150 + 100; const y = Math.random() * 150 + 100;
                    const platformType = Math.random();
                    if (platformType < 0.3) platforms.push({ x: newAreaStartX + (Math.random() * 100 - 50), y, width, height: 20, type: 'ice' });
                    else if (platformType < 0.45) platforms.push({ x: newAreaStartX + (Math.random() * 100 - 50), y, width: 120, height: 20, type: 'moving_v', originalY: y, moveSpeed: 1, moveRange: 80, moveDir: 1 });
                    else platforms.push({ x: newAreaStartX + (Math.random() * 100 - 50), y, width, height: 20, type: 'normal' });
                    generatedHighPlatform = platforms[platforms.length - 1];

                    if (Math.random() < 0.4) {
                        const x = generatedHighPlatform.x + (width / 2) - 12.5, w = 25;
                        if (!isOccupied(x, w)) { obstacles.push({ x, y: y - 25, width: w, height: 25 }); occupiedSpaces.push({ x, width: w }); }
                    }
                    if (Math.random() < 0.1) {
                        const x = generatedHighPlatform.x + width / 2 - 15, w = 30;
                        if (!isOccupied(x, w)) { turrets.push({ x, y: y - 30, width: w, height: 30, type: 'killer', cooldown: 240 }); occupiedSpaces.push({ x, width: w }); }
                    }

                    // STEP 2: å…¨ã¦ã®å‡ºç¾åˆ¤å®šã«è£œæ­£å€¤ã‚’é©ç”¨
                    if (Math.random() < 0.6 * speedBasedModifier) {
                        const x = generatedHighPlatform.x + width * Math.random();
                        const w = 20;
                        if (!isOccupied(x - w / 2, w)) { timeCoins.push({ x: x, y: y - 40, radius: 10 }); occupiedSpaces.push({ x: x - w / 2, width: w }); }
                    }
                    if (Math.random() < 0.1 * speedBasedModifier) fallRescueItems.push({ x: generatedHighPlatform.x + width * Math.random(), y: y - 40, radius: 12 });
                    if (Math.random() < 0.15 * speedBasedModifier) doubleJumpItems.push({ x: generatedHighPlatform.x + width * Math.random(), y: y - 40, radius: 12 });
                    if (Math.random() < 0.1 * speedBasedModifier) timeStopItems.push({ x: generatedHighPlatform.x + width * Math.random(), y: y - 40, radius: 12 });
                    if (Math.random() < 0.05 * speedBasedModifier) powerUpItems.push({ x: generatedHighPlatform.x + width * Math.random(), y: y - 40, radius: 12 });
                }

                if (!generatedHighPlatform && !generatedLowPlatform) platforms.push({ x: newAreaStartX, y: GAME_HEIGHT - 80, width: 150, height: 20, type: 'normal' });
                if (generatedHighPlatform && generatedLowPlatform) { const high = generatedHighPlatform; const low = generatedLowPlatform; const overlapX_start = Math.max(high.x, low.x); const overlapX_end = Math.min(high.x + high.width, low.x + low.width); if (overlapX_end > overlapX_start && Math.random() < 0.75) { const ladderX = overlapX_start + (overlapX_end - overlapX_start) / 2; ladders.push({ x: ladderX - 15, y: high.y, width: 30, height: low.y - high.y }); } }
                lastGeneratedX = newAreaStartX + 180;
            }
        }
        function spawnBoss() {
            bossFightActive = true;
            let numSides;
            do {
                numSides = Math.floor(Math.random() * (BOSS_MAX_SIDES - BOSS_MIN_SIDES + 1)) + BOSS_MIN_SIDES;
            } while (numSides === lastBossSides && BOSS_MAX_SIDES - BOSS_MIN_SIDES > 0);
            lastBossSides = numSides;

            // â˜…â˜…â˜… ã“ã“ã‹ã‚‰ãŒã€è¨ä¼æ•°é€£å‹•å‹AIã€‘ã®æ–°ãƒ­ã‚¸ãƒƒã‚¯ã§ã™ â˜…â˜…â˜…
            // è¨ä¼æ•°ãŒãã®ã¾ã¾ã€Œæˆé•·ãƒ¬ãƒ™ãƒ«ã€ã«ãªã‚‹
            const growthLevel = bossDefeatCount;

            // åŸºæœ¬HPã¨ä¸Šä½HPã‚’è¨ˆç®—
            const baseHp = 1 + growthLevel;
            const advancedHp = baseHp + 1;

            // ä¸Šä½HPã‚’æŒã¤ãƒ‘ãƒ¼ãƒ„ãŒå‡ºç¾ã™ã‚‹ã€Œç¢ºç‡ã€ã‚’è¨ˆç®—
            // ãƒœã‚¹ã‚’å€’ã™ã”ã¨ã«ã€ã‚ˆã‚Šé«˜ã„HPã®ãƒ‘ãƒ¼ãƒ„ãŒå‡ºã‚„ã™ããªã‚‹
            const advancedHpChance = 0.25 * growthLevel;

            // HPã«ä¸Šé™ã‚’è¨­å®š
            const finalBaseHp = Math.min(baseHp, 9);
            const finalAdvancedHp = Math.min(advancedHp, 10);

            const bossSize = BOSS_BASE_SIZE;
            // â˜…â˜…â˜… ã“ã“ã¾ã§ â˜…â˜…â˜…

            let partDesigns = [];
            const currentRotation = boss ? boss.rotation : 0;

            for (let i = 0; i < numSides * 2; i++) {
                const hp = (Math.random() < advancedHpChance) ? finalAdvancedHp : finalBaseHp;

                partDesigns.push({
                    isCorner: i % 2 === 0,
                    angle: (i * ((Math.PI * 2) / (numSides * 2))) - currentRotation,
                    alive: true,
                    hp: hp,
                    initialHp: hp
                });
            }

            boss = {
                x: cameraX + GAME_WIDTH,
                y: GAME_HEIGHT / 2,
                partDesigns,
                speed: BOSS_BASE_SPEED,
                size: bossSize,
                initialPartsCount: partDesigns.length,
                rotation: 0,
                fireCooldown: 120,
                targetY: GAME_HEIGHT / 2,
                yVelocity: 0
            };
        }

        function showTradeMenu(merchant, index) {
            const gameWrapper = document.querySelector('.game-wrapper');
            const menu = document.createElement('div');
            menu.id = 'trade-menu';
            const itemsToSell = [
                { name: 'ğŸ›¡ï¸ ç„¡æ•µã‚·ãƒ¼ãƒ«ãƒ‰', cost: 500, action: () => { if (player.shieldRescues < 5) player.shieldRescues++; } },
                { name: 'ğŸ•Šï¸ ç©ºä¸­å¾©å¸°', cost: 500, action: () => { if (player.fallRescues < 5) player.fallRescues++; } },
                { name: 'ğŸª¶ ãƒ€ãƒ–ãƒ«ã‚¸ãƒ£ãƒ³ãƒ—', cost: 200, action: () => { if (player.doubleJumps < 5) player.doubleJumps++; } },
                { name: 'â³ æ™‚ã®ç ‚æ™‚è¨ˆ', cost: 350, action: () => { if (player.timeStops < 5) player.timeStops++; } },
                { name: 'ğŸ”¥ ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—', cost: 350, action: () => { if (player.powerUps < 5) player.powerUps++; } },
                { name: 'â° æ™‚é–“å»¶é•· (+30ç§’)', cost: 3000, action: () => { timeLeft += 40; } },

            ];

            itemsToSell.forEach(item => {
                const button = document.createElement('button');
                button.innerHTML = `${item.name} (ã‚¹ã‚³ã‚¢: ${item.cost})`;
                if (score < item.cost) {
                    button.disabled = true;
                }
                button.onclick = () => {
                    if (score >= item.cost) {
                        score -= item.cost;
                        item.action();
                        sfx.trade();
                        closeMenu();
                        merchants.splice(index, 1);
                    }
                };
                menu.appendChild(button);
            });

            const closeButton = document.createElement('button');
            closeButton.textContent = 'ã‚„ã‚ã‚‹';
            closeButton.onclick = () => closeMenu();
            menu.appendChild(closeButton);

            function closeMenu() {
                player.isTrading = false;
                // â˜…â˜…â˜… ãƒ©ãƒƒãƒ‘ãƒ¼è¦ç´ ã‹ã‚‰ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’å‰Šé™¤ã™ã‚‹ã‚ˆã†ã«å¤‰æ›´ â˜…â˜…â˜…
                gameWrapper.removeChild(menu);
            }

            // â˜…â˜…â˜… ãƒ©ãƒƒãƒ‘ãƒ¼è¦ç´ ã«ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’è¿½åŠ ã™ã‚‹ã‚ˆã†ã«å¤‰æ›´ â˜…â˜…â˜…
            gameWrapper.appendChild(menu);
        }

        function savePixelArtJSON() {
            // â˜…â˜…â˜… ãƒ•ã‚¡ã‚¤ãƒ«åã®å…¥åŠ›ã‚’æ±‚ã‚ã‚‹ â˜…â˜…â˜…
            const filename = window.prompt("ãƒ‰ãƒƒãƒˆçµµã®ãƒ•ã‚¡ã‚¤ãƒ«å(JSON)ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:", "my-pixel-art");
            if (!filename) { return; }
            const safeFilename = filename.replace(/[\/\\:*?"<>|]/g, '_');

            const cells = document.querySelectorAll('.pixel-cell');
            const pixelData = Array.from(cells).map(cell => cell.style.backgroundColor || 'transparent');
            const jsonData = { pixels: pixelData };
            const jsonString = JSON.stringify(jsonData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            // â˜…â˜…â˜… å…¥åŠ›ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«åã‚’è¨­å®šï¼ˆæ‹¡å¼µå­.jsonã‚’è¿½åŠ ï¼‰ â˜…â˜…â˜…
            a.download = `${safeFilename}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function loadPixelArtJSON(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const loadedData = JSON.parse(e.target.result);
                    if (loadedData.pixels && Array.isArray(loadedData.pixels) && loadedData.pixels.length === PIXEL_GRID_SIZE * PIXEL_GRID_SIZE) {
                        const cells = document.querySelectorAll('.pixel-cell');
                        cells.forEach((cell, index) => {
                            cell.style.backgroundColor = loadedData.pixels[index];
                        });
                        updatePixelArtPreview(); // â˜…â˜…â˜… èª­è¾¼å¾Œã€ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’æ›´æ–° â˜…â˜…â˜…
                        alert('ãƒ‰ãƒƒãƒˆçµµã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸï¼');
                    } else {
                        alert('ã‚¨ãƒ©ãƒ¼: ç„¡åŠ¹ãªãƒ‰ãƒƒãƒˆçµµãƒ•ã‚¡ã‚¤ãƒ«ã§ã™ã€‚');
                    }
                } catch (error) {
                    alert('ã‚¨ãƒ©ãƒ¼: ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
                }
            };
            reader.readAsText(file);
            event.target.value = null;
        }

        function saveBeat() {
            // â˜…â˜…â˜… ãƒ•ã‚¡ã‚¤ãƒ«åã®å…¥åŠ›ã‚’æ±‚ã‚ã‚‹ â˜…â˜…â˜…
            const filename = window.prompt("ãƒ“ãƒ¼ãƒˆã®ãƒ•ã‚¡ã‚¤ãƒ«å(JSON)ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„:", "my-beat");
            if (!filename) { return; }
            const safeFilename = filename.replace(/[\/\\:*?"<>|]/g, '_');

            const beatData = {
                bpm: BPM,
                patterns: {}
            };
            Object.keys(PARTS).forEach(partName => {
                beatData.patterns[partName] = PARTS[partName].pattern;
            });

            const jsonString = JSON.stringify(beatData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            // â˜…â˜…â˜… å…¥åŠ›ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«åã‚’è¨­å®šï¼ˆæ‹¡å¼µå­.jsonã‚’è¿½åŠ ï¼‰ â˜…â˜…â˜…
            a.download = `${safeFilename}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // â˜…â˜…â˜… ã“ã“ã‹ã‚‰ãŒã€èª­è¾¼æ©Ÿèƒ½ã€‘ã®é–¢æ•°ã§ã™ â˜…â˜…â˜…
        function loadBeat(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const loadedData = JSON.parse(e.target.result);

                    // â˜…â˜…â˜… STEP 1: ãƒ‡ãƒ¼ã‚¿å½¢å¼ã‚’ãƒã‚§ãƒƒã‚¯ â˜…â˜…â˜…
                    if (loadedData.bpm && loadedData.patterns) {

                        // â˜…â˜…â˜… STEP 2: BPMã‚’èª­ã¿è¾¼ã‚“ã§é©ç”¨ â˜…â˜…â˜…
                        BPM = parseInt(loadedData.bpm, 10) || 120; // ç„¡åŠ¹ãªå€¤ãªã‚‰120ã«
                        document.getElementById('bpm-slider').value = BPM;
                        document.getElementById('bpm-display').textContent = BPM;

                        // â˜…â˜…â˜… STEP 3: å…¨ã¦ã®æ¥½å™¨ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’èª­ã¿è¾¼ã‚“ã§é©ç”¨ â˜…â˜…â˜…
                        // ã¾ãšå…¨ãƒ‘ãƒ¼ãƒˆã‚’ã‚¯ãƒªã‚¢
                        Object.keys(PARTS).forEach(partName => {
                            PARTS[partName].pattern.fill(0);
                        });
                        // ãƒ•ã‚¡ã‚¤ãƒ«ã«å­˜åœ¨ã™ã‚‹ãƒ‘ãƒ¼ãƒˆã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å¾©å…ƒ
                        Object.keys(loadedData.patterns).forEach(partName => {
                            // ç¾åœ¨ã®ã‚²ãƒ¼ãƒ ã«å­˜åœ¨ã™ã‚‹æ¥½å™¨ã®å ´åˆã®ã¿èª­ã¿è¾¼ã‚€
                            if (PARTS[partName]) {
                                PARTS[partName].pattern = loadedData.patterns[partName];
                            }
                        });

                        if (isPlaying) {
                            togglePlay();
                        }

                        updateSequencerUI();
                        updateGameDifficulty(); // BPMã‚‚åæ˜ ã•ã›ã‚‹ãŸã‚å¿…ãšå‘¼ã³å‡ºã™
                        alert('ãƒ“ãƒ¼ãƒˆã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸï¼');
                    } else {
                        alert('ã‚¨ãƒ©ãƒ¼: ç„¡åŠ¹ãªãƒ“ãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã§ã™ã€‚ï¼ˆå¤ã„å½¢å¼ã®å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ï¼‰');
                    }
                } catch (error) {
                    alert('ã‚¨ãƒ©ãƒ¼: ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
                }
            };
            reader.readAsText(file);
            event.target.value = null;
        }

        function setupPixelArtIO() {
            document.getElementById('save-pixel-art-json').addEventListener('click', savePixelArtJSON);
            document.getElementById('load-pixel-art-json').addEventListener('click', () => document.getElementById('pixel-art-file-input').click());
            document.getElementById('pixel-art-file-input').addEventListener('change', loadPixelArtJSON);
        }

        function setupAnimationControls() {
            let animationMode = 'none';
            const controls = document.getElementById('animation-controls');
            // â˜…â˜…â˜… ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã¨æ•°å€¤è¡¨ç¤ºã®è¦ç´ ã‚’å–å¾— â˜…â˜…â˜…
            const speedSlider = document.getElementById('anim-speed-slider');
            const speedDisplay = document.getElementById('anim-speed-display');

            // ã‚°ãƒªãƒƒãƒ‰ã®åˆ†å‰²ç·šã‚’æç”»/æ¶ˆå»ã™ã‚‹é–¢æ•° (å†…å®¹ã¯å¤‰æ›´ãªã—)
            const updateGridLines = () => {
                const cells = document.querySelectorAll('.pixel-cell');
                cells.forEach(cell => {
                    cell.classList.remove('split-h', 'split-v');
                });

                if (animationMode === '2frames') { // â˜…â˜…â˜… 2åˆ†å‰²ã®æ¡ä»¶ã‚’è¿½åŠ  â˜…â˜…â˜…
                    for (let i = 0; i < PIXEL_GRID_SIZE * PIXEL_GRID_SIZE; i++) {
                        const y = Math.floor(i / PIXEL_GRID_SIZE);
                        if (y === 15) cells[i].classList.add('split-v'); // ä¸­å¤®ã«æ°´å¹³ç·š1æœ¬
                    }
                } else if (animationMode === '4frames') { // 2x2åˆ†å‰²
                    for (let i = 0; i < PIXEL_GRID_SIZE * PIXEL_GRID_SIZE; i++) {
                        const x = i % PIXEL_GRID_SIZE;
                        const y = Math.floor(i / PIXEL_GRID_SIZE);
                        if (x === 15) cells[i].classList.add('split-h');
                        if (y === 15) cells[i].classList.add('split-v');
                    }
                } else if (animationMode === '6frames') {
                    for (let i = 0; i < PIXEL_GRID_SIZE * PIXEL_GRID_SIZE; i++) {
                        const x = i % PIXEL_GRID_SIZE;
                        const y = Math.floor(i / PIXEL_GRID_SIZE);
                        if (x === 10 || x === 21) cells[i].classList.add('split-h');
                        if (y === 15) cells[i].classList.add('split-v');
                    }
                }
            };

            // ãƒ©ã‚¸ã‚ªãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ (å†…å®¹ã¯å¤‰æ›´ãªã—)
            controls.addEventListener('change', (e) => {
                if (e.target.name === 'anim-mode') {
                    animationMode = e.target.value;
                    updateGridLines();
                }
            });

            // â–¼â–¼â–¼ ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¿½åŠ  â–¼â–¼â–¼
            speedSlider.addEventListener('input', () => {
                // 1. ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®å€¤ã‚’å–å¾—
                const newSpeed = parseInt(speedSlider.value, 10);
                // 2. ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æ›´æ–°
                player.animationSpeed = newSpeed;
                // 3. UIã®æ•°å€¤ã‚’æ›´æ–°
                speedDisplay.textContent = newSpeed;
            });

            // â˜…â˜…â˜… åˆæœŸåŒ–å‡¦ç† â˜…â˜…â˜…
            updateGridLines(); // åˆ†å‰²ç·šã®åˆæœŸè¡¨ç¤º
            player.animationSpeed = parseInt(speedSlider.value, 10); // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é€Ÿåº¦ã‚’åˆæœŸåŒ–
            speedDisplay.textContent = player.animationSpeed; // æ•°å€¤ã®åˆæœŸè¡¨ç¤º
        }

        function setupSequencer() {
            const grid = document.getElementById('sequencer-grid');
            grid.innerHTML = '';
            Object.keys(PARTS).forEach(partName => {
                const row = document.createElement('div');
                row.className = 'part-row';

                const label = document.createElement('div');
                label.className = 'part-label';
                label.textContent = partName;
                row.appendChild(label);

                const buttonsContainer = document.createElement('div');
                buttonsContainer.className = 'step-buttons';

                for (let i = 0; i < TOTAL_STEPS; i++) {
                    const btn = document.createElement('button');
                    btn.className = 'step-btn';
                    if (i % STEPS_PER_BEAT === 0) btn.classList.add('beat');
                    btn.dataset.part = partName;
                    btn.dataset.step = i;

                    btn.addEventListener('click', () => {
                        toggleStep(partName, i);
                        const s = PARTS[partName].sound;
                        sfx.playSound(s.freq, s.duration, s.vol, s.type, s.freqEnd);
                    });
                    buttonsContainer.appendChild(btn);
                }
                row.appendChild(buttonsContainer);
                grid.appendChild(row);
            });

            document.getElementById('play-pause-btn').addEventListener('click', togglePlay);
            document.getElementById('clear-sequencer-btn').addEventListener('click', clearSequencer);
            document.getElementById('save-beat-btn').addEventListener('click', saveBeat);
            document.getElementById('load-beat-btn').addEventListener('click', () => document.getElementById('beat-file-input').click());
            document.getElementById('beat-file-input').addEventListener('change', loadBeat);
            const bpmSlider = document.getElementById('bpm-slider');
            const bpmDisplay = document.getElementById('bpm-display');

            bpmSlider.addEventListener('input', () => {
                // 1. BPMå¤‰æ•°ã‚’ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®å€¤ã§æ›´æ–°
                BPM = parseInt(bpmSlider.value, 10);

                // 2. è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹BPMã®æ•°å€¤ã‚’æ›´æ–°
                bpmDisplay.textContent = BPM;

                // 3. ã‚‚ã—å†ç”Ÿä¸­ãªã‚‰ã€æ–°ã—ã„BPMã§ã‚·ãƒ¼ã‚±ãƒ³ã‚µãƒ¼ã‚’å†èµ·å‹•ã™ã‚‹
                if (isPlaying) {
                    stopSequencer();
                    startSequencer();
                }
                updateGameDifficulty();
            });
        }

        function toggleStep(partName, step) {
            PARTS[partName].pattern[step] = 1 - PARTS[partName].pattern[step]; // 0ã¨1ã‚’åˆ‡ã‚Šæ›¿ãˆ
            updateSequencerUI();
            updateGameDifficulty();
        }

        function togglePlay() {
            initAudio();
            isPlaying = !isPlaying;
            const btn = document.getElementById('play-pause-btn');
            if (isPlaying) {
                btn.textContent = 'åœæ­¢';
                btn.classList.add('active');
                currentStep = 0;
                startSequencer();
            } else {
                btn.textContent = 'å†ç”Ÿ';
                btn.classList.remove('active');
                stopSequencer();
            }
            updateGameDifficulty(); //å†ç”Ÿåœæ­¢ã§ã‚‚é›£æ˜“åº¦ã‚’æ›´æ–°
        }

        function clearSequencer() {
            Object.keys(PARTS).forEach(partName => PARTS[partName].pattern.fill(0));
            updateSequencerUI();
            updateGameDifficulty();
        }

        function startSequencer() {
            if (sequencerInterval) return;
            const intervalMs = (60 / BPM) * 1000 / STEPS_PER_BEAT;

            sequencerInterval = setInterval(() => {
                Object.keys(PARTS).forEach(partName => {
                    if (PARTS[partName].pattern[currentStep] === 1) {
                        const s = PARTS[partName].sound;
                        sfx.playSound(s.freq, s.duration, s.vol, s.type, s.freqEnd);
                    }
                });
                updateSequencerUI();
                currentStep = (currentStep + 1) % TOTAL_STEPS;
            }, intervalMs);
        }

        function stopSequencer() {
            if (sequencerInterval) {
                clearInterval(sequencerInterval);
                sequencerInterval = null;
            }
            document.querySelectorAll('.step-btn.playing').forEach(b => b.classList.remove('playing'));
        }

        function updateSequencerUI() {
            document.querySelectorAll('.step-btn').forEach(btn => {
                const part = btn.dataset.part;
                const step = parseInt(btn.dataset.step, 10);
                if (PARTS[part].pattern[step] === 1) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
                if (isPlaying && step === currentStep) {
                    btn.classList.add('playing');
                } else {
                    btn.classList.remove('playing');
                }
            });
        }

        function updateGameDifficulty() {
            let totalActiveNotes = 0;
            // if (isPlaying) { // â† ã“ã®ifæ–‡ã‚’å‰Šé™¤
            Object.values(PARTS).forEach(part => {
                totalActiveNotes += part.pattern.filter(note => note === 1).length;
            });
            // } // â† ã“ã® } ã‚’å‰Šé™¤

            const baseBpm = 120.0;
            const bpmFactor = BPM / baseBpm;

            const potentialSpeed = totalActiveNotes * 0.1 * bpmFactor;
            const potentialMultiplier = 1.0 + (totalActiveNotes * 0.1 * bpmFactor);

            // â˜…â˜…â˜… å†ç”Ÿä¸­ã‹ã©ã†ã‹ã«å¿œã˜ã¦ã€å®Ÿéš›ã®ã‚²ãƒ¼ãƒ ã¸ã®é©ç”¨ã‚’åˆ†ã‘ã‚‹ â˜…â˜…â˜…
            if (isPlaying) {
                forcedScrollSpeed = Math.min(potentialSpeed, 5.0);
                scoreMultiplier = potentialMultiplier;
            } else {
                forcedScrollSpeed = 0;
                // å†ç”Ÿã—ã¦ã„ãªã„æ™‚ã¯ã‚¹ã‚³ã‚¢å€ç‡ã‚’1.0ã«æˆ»ã™
                scoreMultiplier = 1.0;
            }

            // â˜…â˜…â˜… UIã®è¡¨ç¤ºã¯å¸¸ã«è¡Œã† â˜…â˜…â˜…
            const speedText = potentialSpeed > 0 ? potentialSpeed.toFixed(1) : 'OFF';
            document.querySelector('#track-info span:first-child').textContent = `ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«: ${speedText}`;
            document.querySelector('#track-info span:last-child').textContent = `ã‚¹ã‚³ã‚¢å€ç‡: x${potentialMultiplier.toFixed(1)}`;
        }
        function setupHelpModal() {
            const helpButton = document.getElementById('show-help-btn');
            const helpModal = document.getElementById('help-modal');
            const closeHelpModalBtn = document.getElementById('close-help-modal');
            const gameWrapper = document.querySelector('.game-wrapper'); // â˜…â˜…â˜… ã‚²ãƒ¼ãƒ ãƒ©ãƒƒãƒ‘ãƒ¼ã‚’å–å¾— â˜…â˜…â˜…

            if (!helpButton || !helpModal || !closeHelpModalBtn || !gameWrapper) return;

            const openModal = () => {
                initAudio();
                sfx.playSound(523, 0.1, 0.2, 'triangle');
                helpModal.classList.add('open');
                player.isHelpOpen = true; // ã‚²ãƒ¼ãƒ ã‚’åœæ­¢
                // â˜…â˜…â˜… ã‚²ãƒ¼ãƒ ãƒ©ãƒƒãƒ‘ãƒ¼ã«ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’è¿½åŠ  â˜…â˜…â˜…
                gameWrapper.appendChild(helpModal);
            };

            const closeModal = () => {
                helpModal.classList.remove('open');
                player.isHelpOpen = false; // ã‚²ãƒ¼ãƒ ã‚’å†é–‹
                // â˜…â˜…â˜… gameWrapperã«å­˜åœ¨ã™ã‚Œã°å‰Šé™¤ â˜…â˜…â˜…
                if (gameWrapper.contains(helpModal)) {
                    gameWrapper.removeChild(helpModal);
                }
            };

            helpButton.addEventListener('click', openModal);
            closeHelpModalBtn.addEventListener('click', closeModal);

            helpModal.addEventListener('click', (e) => {
                if (e.target === helpModal) {
                    closeModal();
                }
            });

            // â˜…â˜…â˜… bodyã§ã¯ãªããƒ©ãƒƒãƒ‘ãƒ¼ã‹ã‚‰åˆæœŸçŠ¶æ…‹ã§å–ã‚Šé™¤ã„ã¦ãŠã â˜…â˜…â˜…
            if (document.body.contains(helpModal)) {
                document.body.removeChild(helpModal);
            }
        }

        // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼æƒ…å ±ã‚’ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã¨ã—ã¦ç”Ÿæˆã™ã‚‹é–¢æ•°
        function createCharacterData() {
            const animationMode = document.querySelector('input[name="anim-mode"]:checked').value;
            const tempCanvas = getPixelCanvas();
            const tempCtx = tempCanvas.getContext('2d');
            const imageData = tempCtx.getImageData(0, 0, PIXEL_GRID_SIZE, PIXEL_GRID_SIZE);
            const data = imageData.data;
            let minX_total = PIXEL_GRID_SIZE, maxX_total = -1, minY_total = PIXEL_GRID_SIZE, maxY_total = -1, hasDrawing = false;
            for (let i = 0; i < data.length; i += 4) { if (data[i + 3] > 0) { hasDrawing = true; const x = (i / 4) % PIXEL_GRID_SIZE, y = Math.floor((i / 4) / PIXEL_GRID_SIZE); minX_total = Math.min(minX_total, x); maxX_total = Math.max(maxX_total, x); minY_total = Math.min(minY_total, y); maxY_total = Math.max(maxY_total, y); } }
            if (!hasDrawing) return null;

            let finalWidth, finalHeight;
            let isAnimated = false, frameCount = 0, frameWidth = 0, frameHeight = 0;

            if (animationMode === 'none') {
                const effectiveWidth = (maxX_total - minX_total + 1), effectiveHeight = (maxY_total - minY_total + 1), scale = PLAYER_MAX_SIZE / PIXEL_GRID_SIZE;
                finalWidth = Math.max(PLAYER_MIN_SIZE, Math.min(effectiveWidth * scale, PLAYER_MAX_SIZE));
                finalHeight = Math.max(PLAYER_MIN_SIZE, Math.min(effectiveHeight * scale, PLAYER_MAX_SIZE));
            } else {
                isAnimated = true;
                const cols = (animationMode === '6frames') ? 3 : (animationMode === '4frames') ? 2 : 1, rows = 2;
                frameCount = cols * rows;
                let maxFramePixelWidth = 0, maxFramePixelHeight = 0;
                const colWidths = (cols === 3) ? [11, 11, 10] : (cols === 2) ? [16, 16] : [32], rowHeights = [16, 16], colStarts = (cols === 3) ? [0, 11, 22] : (cols === 2) ? [0, 16] : [0], rowStarts = [0, 16];
                for (let r = 0; r < rows; r++) { for (let c = 0; c < cols; c++) { const cellStartX = colStarts[c], cellStartY = rowStarts[r], cellWidth = colWidths[c], cellHeight = rowHeights[r]; let minX_frame = PIXEL_GRID_SIZE, maxX_frame = -1, minY_frame = PIXEL_GRID_SIZE, maxY_frame = -1, hasDrawingInFrame = false; for (let y = cellStartY; y < cellStartY + cellHeight; y++) { for (let x = cellStartX; x < cellStartX + cellWidth; x++) { const i = (y * PIXEL_GRID_SIZE + x) * 4; if (data[i + 3] > 0) { hasDrawingInFrame = true; minX_frame = Math.min(minX_frame, x); maxX_frame = Math.max(maxX_frame, x); minY_frame = Math.min(minY_frame, y); maxY_frame = Math.max(maxY_frame, y); } } } if (hasDrawingInFrame) { const frameContentWidth = maxX_frame - minX_frame + 1, frameContentHeight = maxY_frame - minY_frame + 1; maxFramePixelWidth = Math.max(maxFramePixelWidth, frameContentWidth); maxFramePixelHeight = Math.max(maxFramePixelHeight, frameContentHeight); } } }
                frameWidth = Math.ceil((maxX_total - minX_total + 1) / cols);
                frameHeight = Math.ceil((maxY_total - minY_total + 1) / rows);
                const scale = PLAYER_MAX_SIZE / (PIXEL_GRID_SIZE / Math.max(cols, rows));
                finalWidth = Math.max(PLAYER_MIN_SIZE, Math.min(maxFramePixelWidth * scale, PLAYER_MAX_SIZE));
                finalHeight = Math.max(PLAYER_MIN_SIZE, Math.min(maxFramePixelHeight * scale, PLAYER_MAX_SIZE));
            }

            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = (maxX_total - minX_total + 1);
            finalCanvas.height = (maxY_total - minY_total + 1);
            finalCanvas.getContext('2d').drawImage(tempCanvas, minX_total, minY_total, finalCanvas.width, finalCanvas.height, 0, 0, finalCanvas.width, finalCanvas.height);

            const imageDataUrl = finalCanvas.toDataURL();
            const img = new Image();
            img.src = imageDataUrl;

            // è‰²ã®å‚¾å‘ã‚’åˆ†æã—ã¦è¿”ã™
            const colorAbility = analyzeAndApplyImage(finalCanvas, false); // â† â˜…â˜…â˜… ã“ã“ã®å‘¼ã³å‡ºã—æ–¹ãŒä¸å…·åˆã®åŸå›  â˜…â˜…â˜…

            return {
                width: finalWidth, height: finalHeight, isAnimated, image: isAnimated ? null : img, spriteSheet: isAnimated ? img : null,
                frameCount, frameWidth, frameHeight, colorAbility, imageDataUrl
            };
        }


        // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’ã‚¹ãƒ­ãƒƒãƒˆã«ä¿å­˜ã™ã‚‹ãƒ¡ã‚¤ãƒ³ã®é–¢æ•°
        function saveCharacterToSlot(slotIndex) {
            initAudio();
            const charData = createCharacterData();
            if (!charData) { alert("æç”»ã‚¨ãƒªã‚¢ã«ä½•ã‚‚æã‹ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"); return; }
            player.characterSlots[slotIndex] = charData;
            const slotElement = document.getElementById(`slot-${slotIndex + 1}`);
            slotElement.textContent = '';
            slotElement.style.backgroundImage = `url(${charData.imageDataUrl})`;
            sfx.itemGet();
            alert(`ã‚¹ãƒ­ãƒƒãƒˆ${slotIndex + 1}ã«ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã‚’ä¿å­˜ã—ã¾ã—ãŸï¼`);
        }

        function switchCharacter(slotIndex) {
            if (gameOver || player.isTrading || player.isHelpOpen || !player.characterSlots[slotIndex]) return;

            const newChar = player.characterSlots[slotIndex];

            const oldHeight = player.height;
            Object.assign(player, {
                width: newChar.width, height: newChar.height, isAnimated: newChar.isAnimated, image: newChar.image,
                spriteSheet: newChar.spriteSheet, frameCount: newChar.frameCount, currentFrame: 0, frameWidth: newChar.frameWidth,
                frameHeight: newChar.frameHeight, colorAbility: newChar.colorAbility,
            });
            player.y -= (player.height - oldHeight);
            updatePlayerStats(); // æ–°ã—ã„ã‚µã‚¤ã‚ºã«åˆã‚ã›ã¦ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã‚’å†è¨ˆç®—

            player.shotCooldown = 0;
            player.hoverFuel = player.hoverFuelMax;

            sfx.playSound(600, 0.15, 0.3, 'square', 400); // å¤‰èº«éŸ³
        }



        function setupCharacterSlots() {
            // ä¿å­˜ãƒœã‚¿ãƒ³
            document.getElementById('save-to-slot-1').addEventListener('click', () => saveCharacterToSlot(0));
            document.getElementById('save-to-slot-2').addEventListener('click', () => saveCharacterToSlot(1));
            document.getElementById('save-to-slot-3').addEventListener('click', () => saveCharacterToSlot(2));

            // ã‚¹ãƒ­ãƒƒãƒˆã®ã‚¯ãƒªãƒƒã‚¯/ã‚¿ãƒƒãƒ—ã«ã‚ˆã‚‹å¤‰èº«
            document.getElementById('slot-1').addEventListener('click', () => switchCharacter(0));
            document.getElementById('slot-2').addEventListener('click', () => switchCharacter(1));
            document.getElementById('slot-3').addEventListener('click', () => switchCharacter(2));
        }

        // document.addEventListener('keydown', ...) ã®ä¸­èº«ã‚’ä¿®æ­£
        document.addEventListener('keydown', (e) => {
            initAudio();
            // 1, 2, 3ã‚­ãƒ¼ã§ã®å¤‰èº«
            if (e.code === 'Digit1') switchCharacter(0);
            if (e.code === 'Digit2') switchCharacter(1);
            if (e.code === 'Digit3') switchCharacter(2);
            keys[e.code] = true;
        });

        function initializeGame() {
            initPixelEditor(); // ãƒ”ã‚¯ã‚»ãƒ«ã‚¨ãƒ‡ã‚£ã‚¿ã‚’åˆæœŸåŒ–
            setupSequencer();  // ã‚·ãƒ¼ã‚±ãƒ³ã‚µãƒ¼ã®UIã‚’ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
            setupPixelArtIO();
            setupAnimationControls();
            setupHelpModal();
            setupCharacterSlots();
            init();            // ã‚²ãƒ¼ãƒ ã®åˆå›ã‚¹ã‚¿ãƒ¼ãƒˆ
        }

        function init() {
            // ã‚·ãƒ¼ã‚±ãƒ³ã‚µãƒ¼ã®çŠ¶æ…‹ã¯ç¶­æŒã™ã‚‹
            updateGameDifficulty();

            // â˜…â˜…â˜… ã“ã“ã‹ã‚‰ãŒã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ„›ç€ã‚’å°Šé‡ã™ã‚‹ã€‘æ–°ãƒªã‚»ãƒƒãƒˆå‡¦ç†ã§ã™ â˜…â˜…â˜…

            // 1. ã¾ãšã€ç¾åœ¨ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ã®æ€§èƒ½ï¼ˆç‰¹ã«æœ€å¤§ç‡ƒæ–™ï¼‰ã‚’å†è¨ˆç®—ã•ã›ã‚‹
            //    ã“ã‚Œã«ã‚ˆã‚Šã€ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼å‰ã®ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ãŒä½¿ã£ã¦ã„ãŸæ­£ã—ã„ `hoverFuelMax` ãŒç¢ºå®šã™ã‚‹
            updatePlayerStats();

            // 2. æ¬¡ã«ã€ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹ã¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å…¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’åˆæœŸå€¤ã«æˆ»ã™
            //    â€» è¦‹ãŸç›®ã«é–¢ã™ã‚‹ `image`, `width`, `height`, `colorAbility` ã¯å¤‰æ›´ã—ãªã„ï¼
            Object.assign(player, {
                x: 100, y: 450, velocityX: 0, velocityY: 0,
                onGround: false, onLadder: false, angle: 0,
                shieldRescues: 1, fallRescues: 1, doubleJumps: 1, timeStops: 1, powerUps: 1,
                invincible: false, invincibleTimer: 0,
                poweredUp: false, powerUpTimer: 0,
                shotCooldown: 0,
                hoverFuel: player.hoverFuelMax, // â˜…â˜…â˜… æ­£ã—ã„æœ€å¤§å€¤ã§å…¨å¿«ï¼ â˜…â˜…â˜…
                isTrading: false, isGravityReversing: false, isHelpOpen: false,
                coyoteTimeCounter: 0
            });

            // 3. ã‚²ãƒ¼ãƒ å…¨ä½“ã®å¤‰æ•°ã‚’ãƒªã‚»ãƒƒãƒˆ
            score = 0; lastPositionScore = Math.floor(player.x / 10);
            bossDefeatCount = 0;
            scoreAtLastBossDefeat = 0;
            cameraX = 0;
            gameOver = false;
            timeLeft = INITIAL_TIME;
            frameCounter = 0;
            platforms = []; obstacles = []; ladders = []; groundEnemies = []; airEnemies = []; jumpPads = []; timeCoins = []; shieldRescueItems = []; fallRescueItems = []; doubleJumpItems = []; turrets = []; playerProjectiles = []; enemyProjectiles = []; merchants = []; timeStopItems = []; powerUpItems = []; bossBeams = [];
            boss = null;
            bossFightActive = false;
            nextBossScore = BOSS_SPAWN_SCORE_INTERVAL;
            isTimeFrozen = false;
            timeFreezeTimer = 0;
            gameOverScreen.style.display = 'none';
            platforms.push({ x: 0, y: GAME_HEIGHT - 40, width: 400, height: 20, type: 'normal' });

            // â˜…â˜…â˜… ã“ã“ã¾ã§ â˜…â˜…â˜…

            gameLoop();
        }

        function update() {
            if (gameOver || player.isTrading || player.isHelpOpen) return;

            if (player.isAnimated) {
                player.animationTimer++;
                if (player.animationTimer >= player.animationSpeed) {
                    player.animationTimer = 0;
                    player.currentFrame = (player.currentFrame + 1) % player.frameCount;
                }
            }

            bossBeams.forEach((beam, index) => {
                beam.lifespan--;
                if (beam.lifespan <= 0) {
                    bossBeams.splice(index, 1);
                } else {
                    // â˜…â˜…â˜… ãƒ“ãƒ¼ãƒ ã®ç¨®é¡ã§ç™ºå°„ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’åˆ†å² â˜…â˜…â˜…
                    const activationThreshold = (beam.type === 'angled') ? 60 : 90; // å°„ç·šãƒ“ãƒ¼ãƒ ã¯60ã€å‚ç›´ã¯90
                    if (beam.lifespan < activationThreshold) {
                        beam.state = 'active';
                    }

                    // å‚ç›´ãƒ“ãƒ¼ãƒ ã®ä½ç½®ã‚’ãƒœã‚¹ã«è¿½å¾“ã•ã›ã‚‹å‡¦ç† (å°„ç·šãƒ“ãƒ¼ãƒ ã¯ç™ºå°„ä½ç½®å›ºå®šãªã®ã§ä½•ã‚‚ã—ãªã„)
                    if (boss && beam.type === 'vertical') {
                        beam.x = boss.x;
                    }
                }
            });
            frameCounter++;

            if (isTimeFrozen) {
                timeFreezeTimer--;
                if (timeFreezeTimer <= 0) isTimeFrozen = false;
            } else {
                if (frameCounter >= 60) { timeLeft--; frameCounter = 0; }
                if (timeLeft <= 0) { timeLeft = 0; sfx.gameOver(); gameOver = true; }
                platforms.forEach((p, index) => { if (p.state === 'shaking') { p.timer--; if (p.timer <= 0) platforms.splice(index, 1); } if (p.type === 'moving_h') { p.x += p.moveSpeed * p.moveDir; if (p.x < p.originalX || p.x > p.originalX + p.moveRange) p.moveDir *= -1; } if (p.type === 'moving_v') { p.y += p.moveSpeed * p.moveDir; if (p.y < p.originalY || p.y > p.originalY + p.moveRange) p.moveDir *= -1; } if (p.type === 'ice_block') { p.lifespan--; if (p.lifespan <= 0) platforms.splice(index, 1); } });
                [...groundEnemies, ...airEnemies].forEach(e => { if (e.vx) { e.x += e.vx; if (e.x < e.initialX || e.x > e.initialX + e.moveRange) e.vx *= -1; } if (e.vy) { e.y += e.vy; if (e.y < e.initialY || e.y > e.initialY + e.moveRange) e.vy *= -1; } });
                turrets.forEach(t => { if (Math.abs((t.x + t.width / 2) - (player.x + player.width / 2)) < GAME_WIDTH / 1.5) { t.cooldown--; if (t.cooldown <= 0) { sfx.enemyShoot(); const angle = Math.atan2((player.y + player.height / 2) - (t.y), (player.x + player.width / 2) - (t.x + t.width / 2)); const speed = t.type === 'killer' ? 2 : 4; enemyProjectiles.push({ x: t.x + t.width / 2, y: t.y, radius: 5, type: t.type, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, lifespan: 600 }); t.cooldown = 180 + Math.random() * 120; } } });
                for (let i = enemyProjectiles.length - 1; i >= 0; i--) { const p = enemyProjectiles[i]; if (p.type === 'killer') { const angle = Math.atan2((player.y + player.height / 2) - p.y, (player.x + player.width / 2) - p.x); p.vx += Math.cos(angle) * 0.05; p.vy += Math.sin(angle) * 0.05; p.vx *= 0.99; p.vy *= 0.99; } p.x += p.vx; p.y += p.vy; p.lifespan--; if (p.lifespan <= 0) enemyProjectiles.splice(i, 1); }
            }

            if (player.poweredUp) { player.powerUpTimer--; if (player.powerUpTimer <= 0) player.poweredUp = false; }
            if (player.invincible) { player.invincibleTimer--; if (player.invincibleTimer <= 0) player.invincible = false; }
            if (player.shotCooldown > 0) { player.shotCooldown = Math.max(0, player.shotCooldown - 1); }
            if (player.coyoteTimeCounter > 0) { player.coyoteTimeCounter--; }

            if (score >= scoreAtLastBossDefeat + BOSS_SPAWN_SCORE_INTERVAL && !bossFightActive) { spawnBoss(); }
            if (bossFightActive && boss) {
                if (boss.partDesigns && boss.partDesigns.length > 0) {
                    if (!isTimeFrozen) {
                        boss.rotation += BOSS_ROTATION_SPEED;
                        if (frameCounter % 180 === 0) { boss.targetY = Math.random() * (GAME_HEIGHT - 200) + 100; }
                        const yDiff = boss.targetY - boss.y;
                        boss.yVelocity += yDiff * 0.0005;
                        boss.yVelocity *= 0.95;
                        boss.y += boss.yVelocity;

                        // â˜…â˜…â˜… ã“ã“ã‹ã‚‰ãŒã€ç”»é¢å³ã®æ”¯é…è€…AIã€‘ã§ã™ â˜…â˜…â˜…
                        if (forcedScrollSpeed > 0) {
                            // å¼·åˆ¶ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ä¸­ã¯ã€ç”»é¢ã®å³ç«¯ã«ä½ç½®ã‚’å›ºå®šã™ã‚‹
                            // ãƒœã‚¹ã®æœ€ã‚‚å³å´ã®ãƒ‘ãƒ¼ãƒ„ãŒã€ç”»é¢ã®å³ç«¯ã‹ã‚‰å°‘ã—ã¯ã¿å‡ºã™ãã‚‰ã„ã®ä½ç½®
                            const targetX = cameraX + GAME_WIDTH - boss.size * 0.8;
                            // å¸¸ã«ç›®æ¨™ä½ç½®ã«å‘ã‹ã£ã¦æ»‘ã‚‰ã‹ã«ç§»å‹•ã™ã‚‹
                            boss.x += (targetX - boss.x) * 0.1;
                        } else {
                            // é€šå¸¸æ™‚ã¯ã€ã“ã‚Œã¾ã§é€šã‚Šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¿½ã„ã‹ã‘ã‚‹
                            if (player.x + player.width / 2 < boss.x) {
                                boss.x = Math.max(player.x + player.width, boss.x - boss.speed);
                            }
                        }
                        boss.fireCooldown--;
                        if (boss.fireCooldown <= 0) {
                            const livingParts = boss.partDesigns.filter(p => p.alive);
                            if (livingParts.length > 0) {
                                const difficultyLevel = bossDefeatCount;
                                const attackChoice = Math.random();

                                // 30%ã®ç¢ºç‡ã§ã€Œå‚ç›´ãƒ“ãƒ¼ãƒ ã€
                                if (attackChoice < 0.3) {
                                    sfx.playSound(100, 1.5, 0.4, 'sawtooth', 50);
                                    let minX = Infinity, maxX = -Infinity;
                                    livingParts.forEach(p => { const radius = p.isCorner ? boss.size : boss.size / 2; const x = boss.x + Math.cos(p.angle + boss.rotation) * radius; minX = Math.min(minX, x); maxX = Math.max(maxX, x); });
                                    const calculatedWidth = (maxX - minX) * 1.2;
                                    const beamWidth = Math.max(calculatedWidth, BOSS_PART_SIZE);
                                    bossBeams.push({ x: boss.x, y: 0, width: beamWidth, height: GAME_HEIGHT, lifespan: 120, state: 'charging', type: 'vertical' }); // Yåº§æ¨™ã¯ç„¡è¦–ã•ã‚Œã‚‹
                                    boss.fireCooldown = 240 + Math.random() * 120;

                                    // 30%ã®ç¢ºç‡ã§ã€Œå°„ç·šãƒ“ãƒ¼ãƒ ã€ (NEW!)
                                } else if (attackChoice < 0.6) {
                                    sfx.playSound(120, 1.0, 0.4, 'sine', 80);
                                    const beamThickness = 30; // ãƒ“ãƒ¼ãƒ ã®å¤ªã•
                                    const beamLength = GAME_WIDTH * 1.5; // ç”»é¢ã‚’è²«é€šã™ã‚‹ã®ã«ååˆ†ãªé•·ã•

                                    // ãƒ©ãƒ³ãƒ€ãƒ ãªç”Ÿãã¦ã„ã‚‹ãƒ‘ãƒ¼ãƒ„ã‚’ï¼‘ã¤é¸ã¶
                                    const partToFireFrom = livingParts[Math.floor(Math.random() * livingParts.length)];
                                    const radius = partToFireFrom.isCorner ? boss.size : boss.size / 2;
                                    const partX = boss.x + Math.cos(partToFireFrom.angle + boss.rotation) * radius;
                                    const partY = boss.y + Math.sin(partToFireFrom.angle + boss.rotation) * radius;

                                    // ãã®ãƒ‘ãƒ¼ãƒ„ã‹ã‚‰ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä¸­å¿ƒã¸ã®è§’åº¦ã‚’è¨ˆç®—
                                    const angle = Math.atan2((player.y + player.height / 2) - partY, (player.x + player.width / 2) - partX);

                                    bossBeams.push({ x: partX, y: partY, length: beamLength, thickness: beamThickness, angle: angle, lifespan: 120, state: 'charging', type: 'angled' });
                                    boss.fireCooldown = 180 + Math.random() * 80;


                                    // æ®‹ã‚Šã®40%ã®ç¢ºç‡ã§ã€Œé€šå¸¸å¼¾ã€
                                } else {
                                    const minAttackers = Math.min(1 + difficultyLevel, Math.floor(livingParts.length / 2));
                                    const maxAttackers = Math.min(2 + difficultyLevel * 2, livingParts.length);
                                    const numToFire = Math.floor(Math.random() * (maxAttackers - minAttackers + 1)) + minAttackers;
                                    let availableParts = [...livingParts];
                                    for (let i = 0; i < numToFire; i++) { if (availableParts.length === 0) break; const partIndex = Math.floor(Math.random() * availableParts.length); const partDesignToFire = availableParts.splice(partIndex, 1)[0]; const radius = partDesignToFire.isCorner ? boss.size : boss.size / 2; const partX = boss.x + Math.cos(partDesignToFire.angle + boss.rotation) * radius; const partY = boss.y + Math.sin(partDesignToFire.angle + boss.rotation) * radius; sfx.enemyShoot(); const bulletType = Math.random() < 0.3 ? 'killer' : 'cannon'; const speed = bulletType === 'killer' ? 2 : 4; const angle = Math.atan2((player.y + player.height / 2) - (partY + BOSS_PART_SIZE / 2), (player.x + player.width / 2) - (partX + BOSS_PART_SIZE / 2)); enemyProjectiles.push({ x: partX + BOSS_PART_SIZE / 2, y: partY + BOSS_PART_SIZE / 2, radius: 8, type: bulletType, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, lifespan: 600 }); }
                                    const baseCooldown = Math.max(80, 200 - difficultyLevel * 20);
                                    boss.fireCooldown = baseCooldown + Math.random() * 100;
                                }
                            }
                        }
                    }
                    for (let i = playerProjectiles.length - 1; i >= 0; i--) { const p = playerProjectiles[i]; let collided = false; for (let j = boss.partDesigns.length - 1; j >= 0; j--) { const partDesign = boss.partDesigns[j]; if (!partDesign.alive) continue; const radius = partDesign.isCorner ? boss.size : boss.size / 2; const partX = boss.x + Math.cos(partDesign.angle + boss.rotation) * radius; const partY = boss.y + Math.sin(partDesign.angle + boss.rotation) * radius; if (Math.hypot(p.x - (partX + BOSS_PART_SIZE / 2), p.y - (partY + BOSS_PART_SIZE / 2)) < p.radius + BOSS_PART_SIZE / 2) { const attackPower = p.damage || 1; partDesign.hp -= attackPower; sfx.enemyDefeat(); collided = true; if (partDesign.hp <= 0) { partDesign.alive = false; const partScore = BOSS_SCORE_PER_PART * partDesign.initialHp; score += partScore; if (p.type === 'ice') { platforms.push({ x: partX, y: partY, width: BOSS_PART_SIZE, height: BOSS_PART_SIZE, type: 'ice_block', lifespan: 300 }); } } break; } } if (collided && p.damage <= 1) { playerProjectiles.splice(i, 1); } }
                    if (boss.partDesigns.every(p => !p.alive)) { const completionBonus = boss.initialPartsCount * BOSS_SCORE_PER_PART * 0.5; score += completionBonus; sfx.bossDefeat(); boss = null; bossFightActive = false; scoreAtLastBossDefeat = score; bossDefeatCount++; }
                }
                if (boss && !isTimeFrozen && player.x > boss.x + boss.size + GAME_WIDTH / 2) { boss = null; bossFightActive = false; }
            }

            for (let i = playerProjectiles.length - 1; i >= 0; i--) { const p = playerProjectiles[i]; p.x += p.vx; p.y += p.vy; if (Math.hypot(p.x - player.x, p.y - player.y) > GAME_WIDTH) playerProjectiles.splice(i, 1); }

            const wasOnGround = player.onGround;
            let onTopOfLadder = false, canClimbLadder = false, onIce = false;
            platforms.forEach(p => { if (player.onGround && player.x + player.width > p.x && player.x < p.x + p.width && Math.abs((player.y + player.height) - p.y) < 5) { onIce = p.type === 'ice'; } });
            ladders.forEach(l => { const isOverLadder = player.x + player.width > l.x && player.x < l.x + l.width; if (isOverLadder) { if (Math.abs((player.y + player.height) - l.y) < 5) onTopOfLadder = true; if (player.y + player.height > l.y && player.y < l.y + l.height) canClimbLadder = true; } });
            if (canClimbLadder && !onTopOfLadder && (keys['KeyW'] || keys['ArrowUp'] || keys['Space'])) player.onLadder = true;
            if (!canClimbLadder) player.onLadder = false;
            const currentSpeed = (player.y + player.height < GAME_HEIGHT / 2) ? player.speed * windFactor : player.speed;
            if (keys['KeyA'] || keys['ArrowLeft']) { const effectiveSpeed = (forcedScrollSpeed > 0) ? currentSpeed * 0.5 : currentSpeed; player.velocityX = onIce ? player.velocityX - (effectiveSpeed * 0.05) : -effectiveSpeed; player.facing = -1; }
            else if (keys['KeyD'] || keys['ArrowRight']) { player.velocityX = onIce ? player.velocityX + (currentSpeed * 0.05) : currentSpeed; player.facing = 1; }
            else { if (onIce) player.velocityX *= 0.98; else player.velocityX = 0; }
            player.velocityX = Math.max(-currentSpeed, Math.min(currentSpeed, player.velocityX));
            const jumpPressed = keys['KeyW'] || keys['ArrowUp'] || keys['Space'];
            if (player.onLadder) {
                player.velocityY = 0;
                if (keys['KeyW'] || keys['ArrowUp'] || keys['Space']) {
                    player.y -= 2.5;
                }
                if (jumpPressed && !jumpKeyPressedLastFrame) {
                    player.onLadder = false;
                    player.velocityY = -player.jumpPower;
                    sfx.jump();
                }
            }
            else { if (jumpPressed && !jumpKeyPressedLastFrame) { if (player.onGround || onTopOfLadder || player.coyoteTimeCounter > 0) { player.velocityY = -player.jumpPower; player.onGround = false; player.coyoteTimeCounter = 0; sfx.jump(); } else if (player.doubleJumps > 0) { player.velocityY = -player.jumpPower; player.doubleJumps--; sfx.doubleJump(); } } if (player.isGravityReversing) { player.velocityY -= (gravity * 0.1 * (player.poweredUp ? 1.5 : 1.0)); player.onGround = false; } else { player.velocityY += gravity; } }
            const actionPressed = keys['ShiftLeft'] || keys['KeyX'];
            if (player.colorAbility === 'neutral') { if (actionPressed && player.onGround && player.hoverFuel > 0) { player.isGravityReversing = true; } else if (!actionPressed || player.hoverFuel <= 0) { player.isGravityReversing = false; } }
            if (actionPressed) { let damage = 1; let projectileSize = Math.max(4, Math.min(8 * ((player.width * player.height) / (PLAYER_DEFAULT_WIDTH * PLAYER_DEFAULT_HEIGHT)), 16)); if (player.poweredUp) { projectileSize *= 2; damage = 2; } let projectileSpeed = Math.max(4, Math.min(12 / ((player.width * player.height) / (PLAYER_DEFAULT_WIDTH * PLAYER_DEFAULT_HEIGHT)), 16)); const firePitch = 150 / ((player.width * player.height) / (PLAYER_DEFAULT_WIDTH * PLAYER_DEFAULT_HEIGHT)); const icePitch = 600 * ((player.width * player.height) / (PLAYER_DEFAULT_WIDTH * PLAYER_DEFAULT_HEIGHT)); switch (player.colorAbility) { case 'warm': if (player.shotCooldown <= 0) { playerProjectiles.push({ x: player.x + player.width / 2, y: player.y + player.height / 2, radius: projectileSize, type: 'fire', vx: projectileSpeed * player.facing, vy: 0, damage: damage }); player.shotCooldown = player.shotCooldownMax.fire; sfx.shootFire(firePitch); } break; case 'cool': if (player.shotCooldown <= 0) { playerProjectiles.push({ x: player.x + player.width / 2, y: player.y + player.height / 2, radius: projectileSize, type: 'ice', vx: projectileSpeed * player.facing, vy: 0, damage: damage }); player.shotCooldown = player.shotCooldownMax.ice; sfx.shootIce(icePitch); } break; case 'neutral': if (!player.onGround && !player.isGravityReversing && player.hoverFuel > 0) { player.velocityY *= player.poweredUp ? 0.5 : 0.6; player.hoverFuel--; } break; } }
            if (player.isGravityReversing) { if (player.hoverFuel > 0) player.hoverFuel--; } else if (!actionPressed && player.hoverFuel < player.hoverFuelMax) { if (player.hoverFuel < player.hoverFuelMax) player.hoverFuel += player.hoverRefillRate; }
            player.x += player.velocityX; player.y += player.velocityY; player.onGround = false;

            const CEILING_Y = 0; // ç”»é¢ã®ä¸€ç•ªä¸Š
            if (player.y < CEILING_Y) {
                player.y = CEILING_Y; // å¤©äº•ã«å¼µã‚Šä»˜ã‹ã›ã‚‹
                // ä¸Šæ˜‡ä¸­ãªã‚‰ã€å‹¢ã„ã‚’æ­¢ã‚ã‚‹
                if (player.velocityY < 0) {
                    player.velocityY = 0;
                }
            }

            if (forcedScrollSpeed > 0) { player.x = Math.max(player.x, cameraX); const rightWall = cameraX + GAME_WIDTH; if (player.x + player.width > rightWall) { player.x = rightWall - player.width; } }
            platforms.forEach(p => { if (player.velocityY >= 0 && player.x < p.x + p.width && player.x + player.width > p.x && player.y + player.height > p.y && player.y + player.height < p.y + 25) { player.y = p.y - player.height; player.velocityY = 0; player.onGround = true; player.onLadder = false; if (p.type === 'fragile') p.state = 'shaking'; if (p.type.startsWith('moving') && !isTimeFrozen) { player.x += (p.type === 'moving_h' ? p.moveSpeed * p.moveDir : 0); player.y += (p.type === 'moving_v' ? p.moveSpeed * p.moveDir : 0); } } if (player.y + player.height > p.y && player.y < p.y + p.height) { if (player.velocityX < 0 && player.x > p.x && player.x < p.x + p.width + 5) { player.x = p.x + p.width; player.velocityX = 0; } if (player.velocityX > 0 && player.x + player.width > p.x - 5 && player.x + player.width < p.x) { player.x = p.x - player.width; player.velocityX = 0; } } });
            ladders.forEach(l => { if (player.velocityY >= 0 && !player.onLadder && player.x + player.width > l.x && player.x < l.x + l.width && player.y + player.height > l.y && player.y + player.height < l.y + 20) { player.y = l.y - player.height; player.velocityY = 0; player.onGround = true; } });
            jumpPads.forEach(jp => { if (player.velocityY >= 0 && player.x < jp.x + jp.width && player.x + player.width > jp.x && player.y + player.height > jp.y && player.y + player.height < jp.y + 20) { player.velocityY = -player.jumpPower * JUMP_PAD_BOOST; sfx.jump(); } });
            turrets.forEach(t => { if (player.velocityY >= 0 && player.x < t.x + t.width && player.x + player.width > t.x && player.y + player.height > t.y && player.y + player.height < t.y + 25) { player.y = t.y - player.height; player.velocityY = 0; player.onGround = true; } if (player.y + player.height > t.y && player.y < t.y + t.height) { if (player.velocityX < 0 && player.x > t.x && player.x < t.x + t.width) { player.x = t.x + t.width; player.velocityX = 0; } if (player.velocityX > 0 && player.x + player.width > t.x && player.x + player.width < t.x + t.width) { player.x = t.x - player.width; player.velocityX = 0; } } });
            if (wasOnGround && !player.onGround) { player.coyoteTimeCounter = COYOTE_TIME_FRAMES; }
            for (let i = merchants.length - 1; i >= 0; i--) { const m = merchants[i]; if (player.x < m.x + m.width && player.x + player.width > m.x && player.y < m.y + m.height && player.y + player.height > m.y) { if (actionPressed && !actionKeyPressedLastFrame) { player.isTrading = true; showTradeMenu(m, i); return; } } }
            const useItem = () => { if (player.timeStops > 0) { player.timeStops--; isTimeFrozen = true; timeFreezeTimer = 300; sfx.timeStop(); } if (player.powerUps > 0) { player.powerUps--; player.poweredUp = true; player.powerUpTimer = 240; sfx.powerUp(); } };
            const checkItemCollision = (itemArr, onCollect) => { itemArr.forEach((item, index) => { const dist = Math.hypot(player.x + player.width / 2 - item.x, player.y + player.height / 2 - item.y); if (dist < player.width / 2 + item.radius) { onCollect(); itemArr.splice(index, 1); sfx.itemGet(); } }); };
            checkItemCollision(timeCoins, () => { timeLeft += COIN_TIME_BONUS; }); checkItemCollision(shieldRescueItems, () => player.shieldRescues = Math.min(5, player.shieldRescues + 1)); checkItemCollision(fallRescueItems, () => player.fallRescues = Math.min(5, player.fallRescues + 1)); checkItemCollision(doubleJumpItems, () => player.doubleJumps = Math.min(5, player.doubleJumps + 1)); checkItemCollision(timeStopItems, () => player.timeStops = Math.min(5, player.timeStops + 1)); checkItemCollision(powerUpItems, () => player.powerUps = Math.min(5, player.powerUps + 1));
            for (let i = playerProjectiles.length - 1; i >= 0; i--) { const p = playerProjectiles[i]; if (!p) continue; let projectileHit = false; const checkStandardCollision = (enemyArray, isObstacle = false) => { for (let j = enemyArray.length - 1; j >= 0; j--) { const e = enemyArray[j]; if (!e) continue; const entityWidth = e.width || e.radius * 2; const entityHeight = e.height || e.radius * 2; if (Math.hypot(p.x - (e.x + entityWidth / 2), p.y - (e.y + entityHeight / 2)) < p.radius + entityWidth / 2) { if (p.type === 'fire') { enemyArray.splice(j, 1); if (!isObstacle) score += 50; } else if (p.type === 'ice') { platforms.push({ x: e.x, y: e.y, width: entityWidth, height: entityHeight, type: 'ice_block', lifespan: 300 }); enemyArray.splice(j, 1); if (!isObstacle) score += 50; } sfx.enemyDefeat(); return true; } } return false; }; const checkTurretCollision = () => { for (let j = turrets.length - 1; j >= 0; j--) { const t = turrets[j]; if (!t) continue; if (Math.hypot(p.x - (t.x + t.width / 2), p.y - (t.y + t.height / 2)) < p.radius + t.width / 2) { if (p.type === 'fire') { turrets.splice(j, 1); score += 50; } else if (p.type === 'ice') { platforms.push({ x: t.x, y: t.y, width: t.width, height: t.height, type: 'ice_block', lifespan: 300 }); turrets.splice(j, 1); } sfx.enemyDefeat(); return true; } } return false; }; if (checkStandardCollision(groundEnemies)) projectileHit = true; else if (checkStandardCollision(airEnemies)) projectileHit = true; else if (checkTurretCollision()) projectileHit = true; else if (checkStandardCollision(obstacles, true)) projectileHit = true; else if (checkStandardCollision(enemyProjectiles, true)) projectileHit = true; if (projectileHit && p.damage <= 1) { playerProjectiles.splice(i, 1); } }
            if (!player.invincible) {
                const handleDamage = () => { if (player.shieldRescues > 0) { player.shieldRescues--; player.invincible = true; player.invincibleTimer = 120; useItem(); sfx.shieldUse(); return false; } return true; };[...groundEnemies, ...airEnemies].forEach((e) => { if (player.x < e.x + e.width && player.x + player.width > e.x && player.y < e.y + e.height && player.y + player.height > e.y) { if (player.velocityY >= 0 && (player.y + player.height) < e.y + 25) { player.velocityY = -player.jumpPower; score += 50; sfx.enemyDefeat(); if (e.vx !== undefined) { groundEnemies.splice(groundEnemies.indexOf(e), 1); } else { airEnemies.splice(airEnemies.indexOf(e), 1); } } else if (handleDamage()) { sfx.gameOver(); gameOver = true; } } }); obstacles.forEach(o => { if (player.x < o.x + o.width && player.x + player.width > o.x && player.y < o.y + o.height && player.y + player.height > o.y) { if (handleDamage()) { sfx.gameOver(); gameOver = true; } } }); enemyProjectiles.forEach((p, i) => { if (Math.hypot(p.x - (player.x + player.width / 2), p.y - (player.y + player.height / 2)) < p.radius + player.width / 2) { if (handleDamage()) { sfx.gameOver(); gameOver = true; } else { enemyProjectiles.splice(i, 1); } } }); if (boss && !gameOver) { for (const partDesign of boss.partDesigns) { if (partDesign.alive) { const radius = partDesign.isCorner ? boss.size : boss.size / 2; const partX = boss.x + Math.cos(partDesign.angle + boss.rotation) * radius; const partY = boss.y + Math.sin(partDesign.angle + boss.rotation) * radius; if (player.x < partX + BOSS_PART_SIZE && player.x + player.width > partX && player.y < partY + BOSS_PART_SIZE && player.y + player.height > partY) { if (handleDamage()) { sfx.gameOver(); gameOver = true; break; } } } } } // update()é–¢æ•°ã®ä¸­ã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å½“ãŸã‚Šåˆ¤å®šéƒ¨åˆ†
                bossBeams.forEach(beam => {
                    if (beam.state !== 'active') return;

                    if (beam.type === 'vertical') {
                        const beamX = beam.x - beam.width / 2;
                        if (player.x + player.width > beamX && player.x < beamX + beam.width) {
                            if (handleDamage()) { sfx.gameOver(); gameOver = true; }
                        }
                    } else if (beam.type === 'angled') {
                        // â˜…â˜…â˜… å›è»¢ã—ãŸãƒ“ãƒ¼ãƒ ã¨ã®å½“ãŸã‚Šåˆ¤å®šï¼ˆå°‘ã—è¤‡é›‘ã§ã™ï¼‰ â˜…â˜…â˜…
                        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä¸­å¿ƒåº§æ¨™
                        const playerCenterX = player.x + player.width / 2;
                        const playerCenterY = player.y + player.height / 2;

                        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä¸­å¿ƒã‚’ã€ãƒ“ãƒ¼ãƒ ã®ãƒ­ãƒ¼ã‚«ãƒ«åº§æ¨™ã«å¤‰æ›ï¼ˆãƒ“ãƒ¼ãƒ ã‚’åŸç‚¹ãƒ»ç„¡å›è»¢ã«æˆ»ã™ï¼‰
                        const dx = playerCenterX - beam.x;
                        const dy = playerCenterY - beam.y;
                        const rotatedX = dx * Math.cos(-beam.angle) - dy * Math.sin(-beam.angle);
                        const rotatedY = dx * Math.sin(-beam.angle) + dy * Math.cos(-beam.angle);

                        // ãƒ“ãƒ¼ãƒ ã®çŸ©å½¢å†…ã«å…¥ã£ã¦ã„ã‚‹ã‹åˆ¤å®š
                        if (rotatedX >= 0 && rotatedX <= beam.length && Math.abs(rotatedY) <= beam.thickness / 2 + player.width / 2) {
                            if (handleDamage()) { sfx.gameOver(); gameOver = true; }
                        }
                    }
                });
            }
            if (player.y > GAME_HEIGHT + 100) { if (player.fallRescues > 0) { player.fallRescues--; useItem(); player.y = 0; player.x = cameraX + GAME_WIDTH / 2; player.velocityY = 0; sfx.fallUse(); } else { sfx.gameOver(); gameOver = true; } }
            if (forcedScrollSpeed > 0 && player.x + player.width < cameraX - GAME_WIDTH * 2) { sfx.gameOver(); gameOver = true; }
            const oldCameraX = cameraX;
            const oldPlayerX = player.x; // â˜…â˜…â˜… æ›´æ–°å‰ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼Xåº§æ¨™ã‚’è¨˜æ†¶ â˜…â˜…â˜…

            if (forcedScrollSpeed > 0) {
                cameraX += forcedScrollSpeed;
                const boost = (player.x - (cameraX + GAME_WIDTH / 2)) * 0.05;
                if (player.x > cameraX + GAME_WIDTH / 2) cameraX += boost;

            } else {
                cameraX = player.x - (GAME_WIDTH / 2);
            }
            // 1. ç¾åœ¨ã®Xåº§æ¨™ã‚’10ã§å‰²ã£ã¦ã€ç¾åœ¨ã®ã‚¹ã‚³ã‚¢åŸºæº–å€¤ã‚’å–å¾—
            const currentPositionScore = Math.floor(player.x / 10);

            // 2. å‰å›ã®åŸºæº–å€¤ã¨ã®å·®åˆ†ã‚’è¨ˆç®—ï¼ˆãƒ—ãƒ©ã‚¹ãªã‚‰å‰é€²ã€ãƒã‚¤ãƒŠã‚¹ãªã‚‰å¾Œé€€ï¼‰
            const positionDifference = currentPositionScore - lastPositionScore;

            // 3. å·®åˆ†ãŒã‚ã‚Œã°ã‚¹ã‚³ã‚¢ã«åæ˜ ã•ã›ã‚‹
            if (positionDifference !== 0) {
                // ã‚¹ã‚³ã‚¢å€ç‡ã‚’è€ƒæ…®ã—ãŸã‚¹ã‚³ã‚¢ã®å¢—æ¸›é‡ã‚’è¨ˆç®—
                const scoreChange = Math.round(positionDifference * scoreMultiplier);

                // ã‚¹ã‚³ã‚¢ã‚’æ›´æ–°ï¼ˆãŸã ã—0æœªæº€ã«ã¯ãªã‚‰ãªã„ã‚ˆã†ã«ã™ã‚‹ï¼‰
                score = Math.max(0, score + scoreChange);
            }

            // 4. ä»Šå›ã®åŸºæº–å€¤ã‚’ã€Œå‰å›ã®åŸºæº–å€¤ã€ã¨ã—ã¦ä¿å­˜ã—ã€æ¬¡ã®ãƒ•ãƒ¬ãƒ¼ãƒ ã«å‚™ãˆã‚‹
            lastPositionScore = currentPositionScore;
            document.getElementById('shield-rescues-count').textContent = player.shieldRescues; document.getElementById('fall-rescues-count').textContent = player.fallRescues; document.getElementById('double-jumps-count').textContent = player.doubleJumps; document.getElementById('time-stops-count').textContent = player.timeStops; document.getElementById('power-ups-count').textContent = player.powerUps;
            jumpKeyPressedLastFrame = jumpPressed;
            actionKeyPressedLastFrame = actionPressed;
            generateWorld();
        }
        function draw() {
            ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            ctx.save();
            ctx.translate(-cameraX, 0);

            if (isTimeFrozen && timeFreezeTimer > 0) {
                const progress = timeFreezeTimer / 900;
                const r = Math.floor(127 + (135 - 127) * (1 - progress));
                const g = Math.floor(140 + (206 - 140) * (1 - progress));
                const b = Math.floor(141 + (235 - 141) * (1 - progress));
                canvas.style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
            } else {
                canvas.style.backgroundColor = '#87ceeb';
            }

            if (!gameOver && timeLeft <= 10) {
                const blinkSpeed = Math.max(4, 12 - (10 - timeLeft));
                if (frameCounter % blinkSpeed < blinkSpeed / 2) {
                    canvas.style.borderColor = '#836d48';
                    canvas.style.borderWidth = '4px';
                } else {
                    canvas.style.borderColor = '#c0392b';
                    canvas.style.borderWidth = '2px';
                }
            } else {
                canvas.style.borderColor = '#000';
                canvas.style.borderWidth = '2px';
            }

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)'; ctx.lineWidth = 2; ctx.setLineDash([10, 15]); ctx.beginPath(); ctx.moveTo(cameraX, GAME_HEIGHT / 2); ctx.lineTo(cameraX + GAME_WIDTH, GAME_HEIGHT / 2); ctx.stroke(); ctx.setLineDash([]);

            platforms.forEach(p => {
                if (p.type === 'ice_block') {
                    ctx.globalAlpha = p.lifespan / 300;
                    ctx.fillStyle = '#1e90ff';
                    ctx.fillRect(p.x, p.y, p.width, p.height);
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(p.x, p.y, p.width, p.height);
                    ctx.globalAlpha = 1;
                } else {
                    if (p.type === 'ice') ctx.fillStyle = '#a2e0ff';
                    else if (p.type === 'fragile') ctx.fillStyle = p.state === 'shaking' && frameCounter % 10 < 5 ? '#c03b2b' : '#e67e22';
                    else if (p.type.startsWith('moving')) ctx.fillStyle = '#576574';
                    else ctx.fillStyle = '#27ae60';
                    ctx.fillRect(p.x, p.y, p.width, p.height);
                }
            });
            jumpPads.forEach(jp => { ctx.fillStyle = '#9b59b6'; ctx.fillRect(jp.x, jp.y, jp.width, jp.height); });
            ladders.forEach(l => { ctx.fillStyle = '#cd853f'; for (let i = 0; i < l.height / 20; i++) ctx.fillRect(l.x, l.y + i * 20, l.width, 5); });
            ctx.fillStyle = '#f1c40f'; ctx.strokeStyle = '#f39c12'; ctx.lineWidth = 2; timeCoins.forEach(c => { ctx.beginPath(); ctx.arc(c.x, c.y, c.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); });
            ctx.font = '24px Arial'; ctx.textAlign = 'center'; shieldRescueItems.forEach(item => { ctx.fillText('ğŸ›¡ï¸', item.x, item.y + item.radius / 2); }); fallRescueItems.forEach(item => { ctx.fillText('ğŸ•Šï¸', item.x, item.y + item.radius / 2); }); doubleJumpItems.forEach(item => { ctx.fillText('ğŸª¶', item.x, item.y + item.radius / 2); }); timeStopItems.forEach(item => { ctx.fillText('â³', item.x, item.y + item.radius / 2); }); powerUpItems.forEach(item => { ctx.fillText('ğŸ”¥', item.x, item.y + item.radius / 2); });

            if (player.poweredUp) { ctx.save(); ctx.globalAlpha = Math.min(1.0, player.powerUpTimer / 120) * 0.7; ctx.fillStyle = '#FFD700'; const auraSize = Math.max(player.width, player.height) * 1.5; ctx.beginPath(); ctx.arc(player.x + player.width / 2, player.y + player.height / 2, auraSize / 2, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }
            if (!player.invincible || frameCounter % 10 < 5) {
                ctx.save();
                ctx.translate(player.x + player.width / 2, player.y + player.height / 2);
                ctx.scale(player.facing, 1);
                ctx.imageSmoothingEnabled = false;

                // â˜…â˜…â˜… ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ã™ã‚‹ã‹ã©ã†ã‹ã§æç”»ã‚’åˆ†å² â˜…â˜…â˜…
                if (player.isAnimated && player.spriteSheet) {
                    // â–¼â–¼â–¼ ã“ã®ä¸€è¡Œã‚’ä¿®æ­£ â–¼â–¼â–¼
                    const cols = (player.frameCount === 6) ? 3 : (player.frameCount === 4) ? 2 : 1;
                    const sx = (player.currentFrame % cols) * player.frameWidth;
                    const sy = Math.floor(player.currentFrame / cols) * player.frameHeight;

                    ctx.drawImage(player.spriteSheet,
                        sx, sy, player.frameWidth, player.frameHeight,
                        -player.width / 2, -player.height / 2, player.width, player.height
                    );

                } else if (player.image) { // é€šå¸¸ã®ç”»åƒ
                    ctx.drawImage(player.image, -player.width / 2, -player.height / 2, player.width, player.height);

                } else { // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®å››è§’
                    player.color = (player.y + player.height < GAME_HEIGHT / 2) ? '#1abc9c' : '#000000';
                    ctx.fillStyle = player.color;
                    ctx.fillRect(-player.width / 2, -player.height / 2, player.width, player.height);
                }

                // è¿½ã„é¢¨ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ (å…±é€š)
                if ((player.image || player.spriteSheet) && player.y + player.height < GAME_HEIGHT / 2) {
                    ctx.globalAlpha = 0.4;
                    ctx.fillStyle = '#1abc9c';
                    ctx.fillRect(-player.width / 2, -player.height / 2, player.width, player.height);
                    ctx.globalAlpha = 1.0;
                }
                ctx.restore();
            }
            ctx.fillStyle = '#34495e'; groundEnemies.forEach(e => ctx.fillRect(e.x, e.y, e.width, e.height));
            ctx.fillStyle = '#9b59b6'; airEnemies.forEach(e => { ctx.beginPath(); ctx.arc(e.x + e.width / 2, e.y + e.height / 2, e.width / 2, 0, Math.PI * 2); ctx.fill(); });
            turrets.forEach(t => { ctx.fillStyle = '#836d48'; ctx.fillRect(t.x, t.y, t.width, t.height); });
            ctx.fillStyle = '#836d48';
            obstacles.forEach(o => { ctx.beginPath(); ctx.moveTo(o.x, o.y + o.height); ctx.lineTo(o.x + o.width / 2, o.y); ctx.lineTo(o.x + o.width, o.y + o.height); ctx.closePath(); ctx.fill(); });
            playerProjectiles.forEach(p => { ctx.fillStyle = p.type === 'fire' ? 'rgba(255, 69, 0, 0.8)' : 'rgba(100, 180, 255, 0.9)'; ctx.strokeStyle = p.type === 'fire' ? '#ff0' : '#fff'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.fill(); ctx.stroke(); });
            enemyProjectiles.forEach(p => { ctx.fillStyle = 'rgba(80, 80, 80, 0.9)'; ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.fill(); });
            merchants.forEach(m => { ctx.fillStyle = '#DAA520'; ctx.fillRect(m.x, m.y, m.width, m.height); ctx.fillStyle = 'rgba(255, 255, 0, 0.3)'; ctx.beginPath(); ctx.arc(m.x + m.width / 2, m.y + m.height / 2, 50, 0, Math.PI * 2); ctx.fill(); });

            if (bossFightActive && boss) { const hpColors = ['#c0392b', '#e67e22', '#f1c40f', '#2ecc71', '#3498db', '#9b59b6', '#e91e63', '#ecf0f1', '#95a5a6', '#34495e']; boss.partDesigns.forEach(partDesign => { if (partDesign.alive) { const radius = partDesign.isCorner ? boss.size : boss.size / 2; const x = boss.x + Math.cos(partDesign.angle + boss.rotation) * radius; const y = boss.y + Math.sin(partDesign.angle + boss.rotation) * radius; ctx.fillStyle = hpColors[Math.min(partDesign.hp - 1, hpColors.length - 1)] || '#c0392b'; ctx.fillRect(x, y, BOSS_PART_SIZE, BOSS_PART_SIZE); } }); }
            bossBeams.forEach(beam => {
                if (boss) {
                    ctx.globalAlpha = beam.lifespan / 120;
                    if (beam.state === 'charging') {
                        ctx.fillStyle = (frameCounter % 10 < 5) ? 'rgba(255, 100, 100, 0.5)' : 'rgba(255, 0, 0, 0.7)';
                    } else {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    }

                    // â˜…â˜…â˜… ãƒ“ãƒ¼ãƒ ã®ç¨®é¡ã§æç”»ã‚’åˆ†å² â˜…â˜…â˜…
                    if (beam.type === 'vertical') {
                        // â˜…â˜…â˜… Xåº§æ¨™ã®è¨ˆç®—ã‚’ä¿®æ­£ã—ã€ç”»é¢ç«¯ã¾ã§å±Šãã‚ˆã†ã«ã™ã‚‹ â˜…â˜…â˜…
                        const beamX = beam.x - beam.width / 2;
                        ctx.fillRect(beamX, 0, beam.width, boss.y - boss.size - 20);
                        ctx.fillRect(beamX, boss.y + boss.size + 20, beam.width, GAME_HEIGHT);
                    } else if (beam.type === 'angled') {
                        // â˜…â˜…â˜… å›è»¢æç”»å‡¦ç† â˜…â˜…â˜…
                        ctx.save();
                        ctx.translate(beam.x, beam.y); // ãƒ“ãƒ¼ãƒ ã®æ ¹å…ƒã«ç§»å‹•
                        ctx.rotate(beam.angle); // è¨ˆç®—ã—ãŸè§’åº¦ã«å›è»¢
                        ctx.fillRect(0, -beam.thickness / 2, beam.length, beam.thickness); // ãƒ“ãƒ¼ãƒ ã‚’æç”»
                        ctx.restore();
                    }
                    ctx.globalAlpha = 1.0;
                }
            });

            ctx.restore();

            // --- ã“ã“ã‹ã‚‰ãŒç”»é¢å›ºå®šUIã®æç”» (ctxã‚’ä½¿ç”¨ã™ã‚‹ã‚ˆã†ã«ä¿®æ­£) ---
            if (player.colorAbility === 'neutral' && player.hoverFuel < player.hoverFuelMax) { const gaugeWidth = 50; const gaugeHeight = 8; const gaugeX = (player.x + player.width / 2) - cameraX - gaugeWidth / 2; const gaugeY = player.y - gaugeHeight - 5; ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(gaugeX, gaugeY, gaugeWidth, gaugeHeight); ctx.fillStyle = player.hoverFuel > player.hoverFuelMax * 0.25 ? '#2ecc71' : '#836d48'; ctx.fillRect(gaugeX, gaugeY, gaugeWidth * (player.hoverFuel / player.hoverFuelMax), gaugeHeight); }
            if ((player.colorAbility === 'warm' || player.colorAbility === 'cool') && player.shotCooldown > 0) { const gaugeWidth = 50; const gaugeHeight = 8; const gaugeX = (player.x + player.width / 2) - cameraX - gaugeWidth / 2; const gaugeY = player.y - gaugeHeight - 5; ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(gaugeX, gaugeY, gaugeWidth, gaugeHeight); const cooldownMax = (player.colorAbility === 'warm') ? player.shotCooldownMax.fire : player.shotCooldownMax.ice; const gaugeColor = (player.colorAbility === 'warm') ? '#ff6347' : '#1e90ff'; const progress = player.shotCooldown / cooldownMax; ctx.fillStyle = gaugeColor; ctx.fillRect(gaugeX, gaugeY, gaugeWidth * progress, gaugeHeight); }

            ctx.fillStyle = '#fff'; ctx.font = '24px Arial'; ctx.textAlign = 'left'; ctx.fillText(`Score: ${score}`, 10, 30);
            ctx.textAlign = 'right'; ctx.fillText(`Time: ${timeLeft}`, GAME_WIDTH - 10, 30);
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(GAME_WIDTH / 2 - 100, 10, 200, 10);
            ctx.fillStyle = '#f1c40f';

            // â˜…â˜…â˜… ã“ã“ã‹ã‚‰ãŒã€ãƒœã‚¹æˆ¦å¯¾å¿œã€‘ã®æ–°ã‚²ãƒ¼ã‚¸ãƒ­ã‚¸ãƒƒã‚¯ã§ã™ â˜…â˜…â˜…
            let gaugeWidth = 0;
            // ãƒœã‚¹æˆ¦ä¸­ã¯ã‚²ãƒ¼ã‚¸ã‚’MAXã§å›ºå®šè¡¨ç¤ºã™ã‚‹
            if (bossFightActive) {
                gaugeWidth = 200;
            }
            // é€šå¸¸æ™‚ã¯ã€æœ€å¾Œã«ãƒœã‚¹ã‚’å€’ã—ãŸã‚¹ã‚³ã‚¢ã‹ã‚‰ã®å·®åˆ†ã§ã‚²ãƒ¼ã‚¸ã‚’è¨ˆç®—ã™ã‚‹
            else {
                const progressSinceLastBoss = score - scoreAtLastBossDefeat;
                const progressRatio = progressSinceLastBoss / BOSS_SPAWN_SCORE_INTERVAL;
                // ã‚¹ã‚³ã‚¢ãŒä¸‹ãŒã£ãŸå ´åˆãªã©ã«ã‚²ãƒ¼ã‚¸ãŒãƒã‚¤ãƒŠã‚¹ã«ãªã‚‰ãªã„ã‚ˆã†ã«Math.maxã‚’ä½¿ç”¨
                gaugeWidth = Math.min(200, Math.max(0, progressRatio) * 200);
            }
            ctx.fillRect(GAME_WIDTH / 2 - 100, 10, gaugeWidth, 10);

            if (gameOver) { const gameOverText = document.getElementById('game-over-text'); const tweetLink = document.getElementById('tweet-link'); gameOverText.innerHTML = ` <div style="font-size: 50px;">GAME OVER</div> <div style="font-size: 20px;">Final Score: ${score}</div> <div style="font-size: 16px; margin-top: 10px;">ã‚¯ãƒªãƒƒã‚¯ãƒ»ã‚¿ãƒƒãƒ—ã§ãƒªã‚¹ã‚¿ãƒ¼ãƒˆ</div> `; const tweetText = `ã€Œã‚»ãƒ«ãƒ©ãƒ³ãƒŠãƒ¼ã€ã§${score}ç‚¹ã‚’è¨˜éŒ²ã—ã¾ã—ãŸï¼ #ã‚»ãƒ«ãƒ©ãƒ³ãƒŠãƒ¼`; const tweetUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(tweetText)}`; tweetLink.href = tweetUrl; gameOverScreen.style.display = 'flex'; }
        }
        function gameLoop() {
            update();
            draw();
            if (!gameOver) requestAnimationFrame(gameLoop);
        }

        function resizeGameCanvas() {
            const mainContent = document.querySelector('.main-content');
            const legend = document.getElementById('legend');
            const gameWrapper = document.querySelector('.game-wrapper');

            // åˆ©ç”¨å¯èƒ½ãªæç”»ã‚¨ãƒªã‚¢ã®å¹…ã‚’å–å¾— (å·¦å³ã®paddingã‚’è€ƒæ…®)
            const availableWidth = mainContent.clientWidth - 40;

            // åˆ©ç”¨å¯èƒ½ãªæç”»ã‚¨ãƒªã‚¢ã®é«˜ã•ã‚’å–å¾—
            let availableHeight = mainContent.clientHeight - 40; // ä¸Šä¸‹ã®padding

            // å‡¡ä¾‹ãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€ãã®åˆ†ã®é«˜ã•ã‚’å¼•ã
            if (window.getComputedStyle(legend).display !== 'none') {
                availableHeight -= (legend.offsetHeight + 20); // å‡¡ä¾‹ã®é«˜ã•ã¨gap
            }

            // ã‚²ãƒ¼ãƒ ã®å…ƒã€…ã®æ¯”ç‡ (800 / 600)
            const aspectRatio = GAME_WIDTH / GAME_HEIGHT;

            let newWidth = availableWidth;
            let newHeight = newWidth / aspectRatio;

            // è¨ˆç®—ã—ãŸçµæœã€é«˜ã•ãŒåˆ©ç”¨å¯èƒ½é ˜åŸŸã‚’ã¯ã¿å‡ºã‚‹å ´åˆã¯ã€
            // é«˜ã•ã‚’åŸºæº–ã«å¹…ã‚’å†è¨ˆç®—ã™ã‚‹
            if (newHeight > availableHeight) {
                newHeight = availableHeight;
                newWidth = newHeight * aspectRatio;
            }

            // è¨ˆç®—ã—ãŸã‚µã‚¤ã‚ºã‚’ã‚²ãƒ¼ãƒ ã®ãƒ©ãƒƒãƒ‘ãƒ¼ã«é©ç”¨
            gameWrapper.style.width = newWidth + 'px';
            gameWrapper.style.height = newHeight + 'px';
        } window.addEventListener('DOMContentLoaded', resizeGameCanvas);
        window.addEventListener('resize', resizeGameCanvas);

        initializeGame();
    </script>
</body>

</html>
